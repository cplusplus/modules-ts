%!TEX root = std.tex
\setcounter{chapter}{8}
\rSec0[dcl.dcl]{Declarations}%
%\indextext{declaration|(}

%gram: \rSec1[gram.dcl]{Declarations}
%gram:

\noindent
Add new alternatives to \term{declaration} in paragraph 9/1 as follows
\begin{std.txt}
  \begin{bnf}
    \nonterminal{declaration}:\br
      block-declaration\br
      nodeclspec-function-declaration\br
      function-definition\br
      template-declaration\br
      explicit-instantiation\br
      explicit-specialization\br
      linkage-specification\br
      namespace-definition\br
      empty-declaration\br
      attribute-declaration\br
      \added{export-declaration}\br
  \end{bnf}
  \end{std.txt}


\setcounter{section}{0}
\rSec1[dcl.spec]{Specifiers}%

\setcounter{subsection}{5}
\rSec2[dcl.inline]{The \tcode{inline} specifier}%

\noindent
Modify paragraph 9.1.6/6 as follows
\begin{std.txt}
  \resetalinea[5]
  \alinea
  \added{Some definition for}
  \removed{A}\added{a}n inline function or variable shall be 
  \removed{defined}\added{reachable} in every translation 
  unit in which it is odr-used and \added{the function or variable} shall have exactly 
  the same definition in every case (\ref{basic.link}).
  \enternote
  A call to the inline function or a use of 
  the inline variable may be encountered before its definition appears 
  in the translation unit.
  \exitnote
  % 
  If \removed{the} \added{a} definition of a function or variable
  \removed{appears in a translation unit before}
  \added{is reachable at the point of}
  its first declaration as inline,
  the program is ill-formed. If a 
  function or variable with external \added{or module} linkage is 
  declared inline in one translation 
  unit,
  \added{there} \removed{it} shall be
  \added{a reachable} \removed{declared} inline
  \added{declaration} in all translation units in which it 
  \removed{appears}\added{is declared}; 
  no diagnostic is required. An inline function or variable with 
  external \added{or module} linkage 
  shall have the same address in all translation units.
  \enternote
  A \tcode{static} local variable in an inline function with external 
  \added{or module} linkage always refers to the same object. A type 
  defined within the body 
  of an inline function with external \added{or module} linkage is the 
  same type in every translation unit.
  \exitnote
\end{std.txt}

\noindent
Add a new paragraph 9.1.6/7 as follows:
\begin{std.txt}
  \color{addclr}
  \resetalinea[6]
  \alinea
  \added{An exported inline function or variable
  shall be defined in the translation unit
  containing its exported declaration,
  outside the \grammarterm{private-module-fragment} (if any).
  \enternote
  There is no restriction on the linkage (or absence thereof)
  of entities that the function body of an exported inline function
  can reference. A constexpr function (9.1.5) is implicitly inline.
  \exitnote}
\end{std.txt}

\setcounter{section}{6}
\rSec1[basic.namespace]{Namespaces}%
%\indextext{namespaces|(}

\noindent
Add a new paragraph after 9.7/1 as follows:
\begin{std.txt}
  \resetalinea[0]
  \alinea
  A namespace is an optionally-named declarative region. The name of a
  namespace can be used to access entities declared in that namespace;
  that is, the members of the namespace. Unlike other declarative
  regions, the definition of a namespace can be split over several
  parts of one or more translation units.

  %\begin{before}
  %\added{A namespace with external linkage is always 
  %  exported regardless of whether any of its \term{namespace-definition}{s} is
  %  introduced by \tcode{export}.
  %  \enternote
  %  There is no way to define a namespace with module linkage.
  %  \exitnote
  %}\color{addclr}
  %\begin{example}
  %\begin{codeblock}
  %  export module M;
  %  namespace N {    // N has external linkage and is exported
  %  }
  %\end{codeblock}
  %\end{example}
  %\end{before}
  \alinea
  \begin{after}
  \added{\enternote A namespace name with external linkage is exported
  if any of its \term{namespace-definition}{s} is
  exported, or if it contains any
  \grammarterm{export-declaration}{s} (\ref{dcl.module.interface}).
  A namespace is never attached to a module, and never has module
  linkage even if it is not exported.
  \exitnote}
  \color{addclr}
  \begin{example}
  \begin{codeblock}
    export module M;
    namespace N1 {}                     // \tcode{N1} is not exported
    export namespace N2 {}              // \tcode{N2} is exported
    namespace N3 { export int n; }      // \tcode{N3} is exported
  \end{codeblock}
  \end{example}
  \end{after}
\end{std.txt}

\noindent
Add a new subclause 9.11 titled ``\textbf{Modules}'' as follows:

\setcounter{section}{10}
\rSec1[dcl.module]{Modules}%

\rSec2[dcl.module.unit]{Module units and purviews}

\begin{std.txt}\color{addclr}
\begin{before}\color{addclr}
\begin{bnf}
\nonterminal{module-declaration}:\br
   \terminal{export}\opt{} \terminal{module} module-name attribute-specifier-seq\opt{} \terminal{;}
\end{bnf}
\end{before}\begin{after}\color{addclr}
\begin{bnf}
\nonterminal{module-declaration}:\br
   \terminal{export}\opt{} \terminal{module} module-name module-partition\opt{} attribute-specifier-seq\opt{} \terminal{;}
\end{bnf}
\end{after}
  
  \begin{bnf}\color{addclr}
    \nonterminal{module-name}:\br
      module-name-qualifier\opt identifier
  \end{bnf}
  
  \begin{after}
  \begin{bnf}\color{addclr}
    \nonterminal{module-partition}:\br
      \terminal{:} module-name-qualifier\opt identifier
  \end{bnf}
  \end{after}
  
  \begin{bnf}\color{addclr}
    \nonterminal{module-name-qualifier}:\br
      identifier \terminal{.}\br
      module-name-qualifier identifier \terminal{.}
  \end{bnf}
  
  \resetalinea[0]
\alinea A \term{module unit} is a translation unit that contains
a \grammarterm{module-declaration}. A \term{named module} is the
collection of module units with the same \grammarterm{module-name}.
\begin{after}\color{addclr}
Two \grammarterm{module-name}{s} are the same if they are
composed of the same dotted sequence of \grammarterm{identifier}{s}.
\end{after}
\begin{before}\color{addclr}
% This follows from the grammar now.
A translation unit shall not contain more than
one \grammarterm{module-declaration}.
% Modules aren't entities and don't have linkage.
A \grammarterm{module-name}
has external linkage but cannot be found by name lookup.
\end{before}

\alinea
A \term{module interface unit} is a module unit whose
\grammarterm{module-declaration} contains the \texttt{export} keyword;
any other module unit is a \term{module implementation unit}.
\begin{before}\color{addclr}
A named module shall contain exactly one module interface unit.
\end{before}
\begin{after}\color{addclr}
A named module shall contain exactly one module interface unit
with no \grammarterm{module-partition}, known as the
\term{primary module interface unit} of the module.
\end{after}

\begin{after}\color{addclr}
\alinea
A \term{module partition} is
a module unit whose \grammarterm{module-declaration} contains
a \grammarterm{module-partition}.
A named module shall not contain multiple module partitions with
the same dotted sequence of \grammarterm{identifier}{s} in their
\grammarterm{module-partition}.
All module partitions of a module
that are module interface units
shall be directly or indirectly exported
by the primary module interface unit (\ref{dcl.module.import}).
No diagnostic is required for a violation of these rules.
\enternote
Module partitions can only be imported by
other module units in the same module.
The division of a module into module units
is not visible outside the module.
\exitnote
\end{after}

\begin{after}\color{addclr}
\alinea
\begin{example}
\begin{codeblock}
// TU 1
export module A;
export import :Foo;
export int baz();
\end{codeblock}

\begin{codeblock}
// TU 2
export module A:Foo;
import :Internals;
export int foo() { return 2 * (bar() + 1); }
\end{codeblock}

\begin{codeblock}
// TU 3
module A:Internals;
int bar();
\end{codeblock}

\begin{codeblock}
// TU 4
module A;
import :Internals;
int bar() { return baz() - 10; }
int baz() { return 30; }
\end{codeblock}

Module \tcode{A} contains four translation units:
\begin{itemize}
\item a primary module interface unit,
\item a module partition \tcode{A:Foo}, which is a module interface unit
forming part of the interface of module \tcode{A},
\item a module partition \tcode{A:Internals}, which does not contribute
to the external interface of module \tcode{A}, and
\item an implementation module unit providing
a definition of \tcode{bar} and \tcode{baz},
which cannot be imported because
it does not have a partition name.
\end{itemize}
\end{example}
\end{after}

\alinea
A \term{module unit purview} starts at the \grammarterm{module-declaration}
and extends to the end of the translation unit.
The \term{purview} of a named module \tcode{M} is the set of module unit purviews
of \tcode{M}'s module units. 

\alinea
The \term{global module} is the collection of all declarations
not in the purview of any module.   By
extension, such declarations  are said to be in the purview of the
global module. 
\enternote
The global module has no name, no module interface unit, and is not
introduced by any \grammarterm{module-declaration}.
\exitnote

\alinea
  A \term{module} is either a named module or the global module.
  \begin{before}\color{addclr}
  A \grammarterm{proclaimed-ownership-declaration} is
  \term{attached} to the module it nominates; any other declaration
  is attached to the module in whose purview it appears.
  \end{before}
  \begin{after}\color{addclr}
  A declaration is \term{attached} to a module determined as follows:
  \begin{itemize}\color{addclr}
  \item If the declaration
  \begin{itemize}\color{addclr}
  \item is a replaceable global allocation or deallocation
  function (\stdref{new.delete.single}{21.6.2.1}, \stdref{new.delete.array}{21.6.2.2}), or
  \item is a \grammarterm{namespace-declaration} with external linkage, or
  \item appears within a \grammarterm{linkage-specification},
  \end{itemize}\color{addclr}
  it is attached to the global module.

  \item Otherwise, the declaration is
  attached to the module in whose purview it appears.
  \end{itemize}
  \end{after}

% Notion of 'ownership' is unused; removed.
%  \alinea
%  \begin{before}\color{addclr}
%For a namespace-scope declaration $D$ of an entity (other than a
%namespace), if $D$ is within a \grammarterm{proclaimed-ownership-declaration}
%for a module $X$, the entity is said to be \term{owned} by $X$.
%Otherwise, if $D$ is the first declaration of that entity, then that entity is said
%to be \term{owned} by the module in whose purview $D$ appears. 
%\end{before}
%\begin{after}\color{addclr}
%An entity introduced at namespace scope is \term{owned} by the
%module to which its first declaration is attached.
%\end{after}

  \alinea
\color{addclr}
A \grammarterm{module-declaration}
that contains neither \tcode{export}
nor a \grammarterm{module-partition}
implicitly imports the primary module interface unit of the module
as if by a \grammarterm{module-import-declaration}.
\begin{example}
\begin{codeblock}
// TU 1
export module B;
import :Y;                      // OK, does not create interface dependency cycle
int n = y();
\end{codeblock}

\begin{codeblock}
// TU 2
module B:X1;                    // does not implicitly import \tcode{B}
int &a = n;                     // error: \tcode{n} not visible here
\end{codeblock}

\begin{codeblock}
// TU 3
module B:X2;                    // does not implicitly import \tcode{B}
import B;
int &b = n;                     // OK
\end{codeblock}

\begin{codeblock}
// TU 4
module B:Y;                     // does not implicitly import \tcode{B}
int y();
\end{codeblock}

\begin{codeblock}
// TU 5
module B;                       // implicitly imports \tcode{B}
int &c = n;                     // OK
\end{codeblock}
\end{example}
\end{std.txt}

\rSec2[dcl.module.interface]{Export declaration}%

\begin{std.txt}\color{addclr}
  \begin{bnf}\color{addclr}
    \nonterminal{export-declaration}:\br
      \terminal{export} declaration\br 
      \terminal{export} \terminal{\{} declaration-seq${}_{opt}$ \terminal{\}} 
  \end{bnf}

  \resetalinea[0]
  \alinea 
  An \grammarterm{export-declaration} shall appear only
  at namespace scope and only in the purview of a module interface unit. 
  An \grammarterm{export-declaration} shall not appear directly
  or indirectly within an unnamed namespace
  or a \grammarterm{private-module-fragment}.
  An \grammarterm{export-declaration}
  has the declarative effects of its \grammarterm{declaration}
  or its \grammarterm{declaration-seq} (if any).
  An \grammarterm{export-declaration} does not
  establish a scope and its \grammarterm{declaration}
  or \grammarterm{declaration-seq}
  shall not contain an \grammarterm{export-declaration}.

  \alinea
  A declaration is \term{exported} if it is
  \begin{itemize}\color{addclr}
  \item a namespace-scope declaration declared within an
        \grammarterm{export-declaration}, or
  \item a \grammarterm{module-import-declaration} declared with
        the \tcode{export} keyword (\ref{dcl.module.import}), or
  \item a \grammarterm{namespace-definition} that contains an
        exported declaration, or
  \item a declaration within a header unit (\ref{dcl.module.import})
        that satisfies the rules for an exported declaration below.
  \end{itemize}
  The \term{interface} of a module \tcode{M} is the set of all
  exported declarations within its purview.
  \begin{example}
  \begin{codeblock}
  export module M;
  namespace A {         // exported
    export int f();     // exported
    int g();            // not exported
  }
  \end{codeblock}
  The interface of \tcode{M} comprises \tcode{A} and \tcode{A::f}.
  \end{example}

  \alinea
  An exported declaration shall declare at least one name.
  If the declaration is not within a header unit,
  it shall not declare a name with internal linkage.
  %\grammarterm{decl-specifier-seq} (if any) of the
  %\grammarterm{declaration} shall not contain \tcode{static},
  %and the \grammarterm{declaration} shall not be an
  %\grammarterm{unnamed-namespace-definition}.

  \alinea
  \begin{example}
  \begin{after}\color{addclr}
    \begin{codeblock}
      module;
      export int x;             // error: not in the purview of a module interface unit
      export module M;
      namespace {
        export int a;           // error: export within unnamed namespace
      }
      export static int b;      // error: b explicitly declared static
      export int f();           // OK
      export namespace N { }    // OK
      export using namespace N; // error: does not declare a name
    \end{codeblock}
  \end{after}
  \end{example}

  \alinea
  If the \grammarterm{declaration} is a \grammarterm{using-declaration}
  (9.8 [namespace.udecl]), any entity to which the
  \grammarterm{using-declarator} ultimately refers shall have been introduced
  with a name having external linkage.
  \begin{example}
    \begin{codeblock}
      int f()               // f has external linkage
      export module M;
      export using ::f;     // OK
      struct S;
      export using ::S;     // error: S has module linkage
      namespace N {
        int h();
        static int h(int);  // \#1
      }
      export using N::h;    // error: \#1 has internal linkage
    \end{codeblock}
  \end{example}
  \enternote
  Names introduced by \tcode{typedef} declarations
  and \grammarterm{alias-declaration}{s}
  are not so constrained.
  \begin{example}
    \begin{codeblock}
      export module M;
      struct S;
      export using T = S;   // OK: exports name T denoting type S
    \end{codeblock}
  \end{example}
  \exitnote

  \begin{after}\color{addclr}
  \alinea
  If a redeclaration is exported
  and the first declaration was not exported,
  the program is ill-formed.
  \begin{example}
  \begin{codeblock}
  export module M;
  struct S { int n; };
  export typedef S S;   // OK, not a redeclaration of \tcode{struct S}
  export struct S;      // error: exported declaration follows non-exported definition
  \end{codeblock}
  \end{example}
  \end{after}

%  \alinea
%  An \grammarterm{export-declaration} of the form
%  \begin{grammar}
%    @\tcode{export}@ @\tcode{\{} \term{declaration-seq${}_{opt}$} \tcode{\}}@ 
%  \end{grammar}
%  is equivalent to a sequence of declarations formed by prefixing each
%  \grammarterm{declaration} of the \grammarterm{declaration-seq} (if any) with
%  \tcode{export}.

  \alinea
  A name is \term{exported} by a module
  if it is introduced or redeclared
  by an exported declaration in the purview of that module.
  %A namespace-scope
  %\begin{before}\color{addclr}
  %or a class-scope
  %\end{before}
  %declaration lexically
  %contained in an \grammarterm{export-declaration}, as well as the
  %entities and the names it introduces are said to be \term{exported}.
  %\begin{before}\color{addclr}
  %The exported declarations in the interface of a module are reachable from
  %any translation unit importing that module.  
  %\end{before}
  \enternote
  Exported names have either external linkage or no linkage; see \ref{basic.link}.
  \begin{after}\color{addclr}
  Namespace-scope names exported by a module are visible to name lookup
  in any translation unit importing that module; see \ref{basic.scope.namespace}.
  Class and enumeration member names are visible to name lookup in any
  context in which a definition of the type is reachable.
  \end{after}
  \exitnote
%  The declarations introducing names with linkage
%  other than internal linkage introduced or made reachable
%   (via an \grammarterm{import-declaration})
%   in the purview of the module
%  interface unit of a 
%  module \tcode{M} are reachable from the purview of all module
%  implementation units
%  of \tcode{M}. 
  \begin{example}
    \begin{codeblock}
      // Interface unit of M
      export module M;
      export struct X {
        static void f();
        struct Y { };
      };

      namespace {
        struct S { };
      }
      export void f(S);    // OK
      struct T { };
      export T id(T);      // OK
  
      export struct A;     // A exported as incomplete

      export auto rootFinder(double a) {
        return [=](double x) { return (x + a/x)/2; };
      }

      export const int n = 5; // OK: n has external linkage
  
      // Implementation unit of M
      module M;
      struct A {
        int value;
      };
  
      // main program
      import M;
      int main() {
        X::f();                 // OK: \tcode{X} is exported and definition of \tcode{X} is reachable
        X::Y y;                 // OK: \tcode{X::Y} is exported as a complete type
        auto f = rootFinder(2); // OK
        return A{45}.value;     // error: \tcode{A} is incomplete
      }
      \end{codeblock}
  \end{example}

  \alinea
  \enternote
  Redeclaring a name in an \grammarterm{export-declaration}
  cannot change the linkage of the name (\ref{basic.link}).
  \begin{example}
  \begin{codeblock}
    // Interface unit of M
    export module M;
    static int f();             // \#1
    export int f();             // error: \#1 gives internal linkage
    struct S;                   // \#2
    export struct S;            // error: \#2 gives module linkage
    namespace {
      namespace N {
        extern int x;           // \#3
      }
    }
    export int N::x;            // error: \#3 gives internal linkage
  \end{codeblock}
  \end{example}
  \exitnote
%% If the
%% \term{export-declaration} introduces a function template or a variable
%% template then the type of the corresponding current instantiation shall
%% contain only types with external linkage.  If the
%% \term{export-declaration} introduces a template alias then the aliased
%% type shall have external linkage.  If the
%% \term{export-declaration} defines a class template, then all
%% non-internal members of the corresponding current instantiation shall
%% contain only types with external linkage.

%%   \alinea
%%   In a \grammarterm{exported-fragment-group},
%%    each \grammarterm{fragment} is processed
%%   as an exported declaration.

  \alinea
  \enternote
  Declarations in an exported \grammarterm{namespace-definition} 
  or in an exported \grammarterm{linkage-specification} (10.5)
  are
  exported and subject to the rules of exported declarations.
  \exitnote
  \begin{example}
    \begin{codeblock}
    export module M;
    export namespace N {
      int x;                    // OK
      static_assert(1 == 1);    // error: does not declare a name
    }
    \end{codeblock}
  \end{example}
\end{std.txt}


\rSec2[dcl.module.import]{Import declaration}%

\begin{std.txt}\color{addclr}
\begin{before}
  \begin{bnf}\color{addclr}
    \nonterminal{module-import-declaration}:\br
      \terminal{import} module-name attribute-specifier-seq\opt {} \terminal{;}
  \end{bnf}
\end{before}\begin{after}
  \begin{bnf}\color{addclr}
    \nonterminal{module-import-declaration}:\br
      \terminal{export}\opt{} \terminal{import} module-name attribute-specifier-seq\opt {} \terminal{;}\br
      \terminal{export}\opt{} \terminal{import} module-partition attribute-specifier-seq\opt {} \terminal{;}\br
      \terminal{export}\opt{} \terminal{import} header-name attribute-specifier-seq\opt {} \terminal{;}
  \end{bnf}
\end{after}

  \resetalinea[0]
  \alinea
  A \grammarterm{module-import-declaration} shall appear only at
  global scope, and not in a \grammarterm{linkage-specification}.
  In a module unit, a \grammarterm{module-import-declaration} shall
  appear only within the \grammarterm{preamble}.

  \alinea
  A \grammarterm{module-import-declaration} \term{imports} a set of
  translation units determined as described below.
  \enternote
  Namespace-scope names exported by the imported translation units
  become visible in the importing translation unit (\ref{basic.scope.namespace})
  and declarations within the imported translation units become reachable
  in the importing translation unit (\ref{dcl.module.reach})
  after the import declaration.
  \exitnote

  \alinea
  A \grammarterm{module-import-declaration} that specifies
  a \grammarterm{module-name} $M$
  imports all module interface units of $M$.

  \alinea
  A \grammarterm{module-import-declaration} that specifies
  a \grammarterm{module-partition} shall only appear after
  the \grammarterm{module-declaration} in a module unit in
  some module $M$.
  Such a declaration imports the so-named
  \grammarterm{module-partition} of $M$.

  \alinea
  A \grammarterm{module-import-declaration} that specifies
  a \grammarterm{header-name} $H$ imports
  a synthesized \term{header unit},
  which is a translation unit formed by applying
  phases 1 to 7 of translation (\stdref{lex.phases}{5.2})
  to the source file nominated by $H$,
  which shall not contain a \grammarterm{module-declaration}.
  \enternote
  All declarations within a header unit are implicitly
  exported, and are attached to the global module.
  \exitnote
  $H$ shall identify an importable header;
  how the set of importable headers is specified
  is implementation-defined.
  Two
  \grammarterm{module-import-declaration}{s}
  import the same header unit if and only if
  their \grammarterm{header-name}{s} identify the same
  header or source file (\ref{cpp.include}).
  \enternote
  A \grammarterm{module-import-declaration} nominating
  a \grammarterm{header-name} is also recognized by the
  preprocessor, and results in macros defined at the
  end of phase 4 of translation of the header unit
  being made visible as described in \ref{cpp.module}.
  \exitnote
  A declaration of a name with internal linkage is
  permitted within a header unit despite all
  declarations being implicitly exported.
  If such a name is odr-used outside the
  header unit, or by a template
  instantiation whose point of instantiation is outside
  the header unit, the program is ill-formed.

  \alinea
  When a \grammarterm{module-import-declaration} imports
  a translation unit $T$, it also imports
  all translation units imported by
  exported \grammarterm{module-import-declaration}{s}
  in $T$; such translation units are
  said to be exported by $T$.
  When a \grammarterm{module-import-declaration} in a module unit imports
  another module unit of the same module, it also imports
  all translation units imported by
  all \grammarterm{module-import-declaration}{s}
  in that module unit.
  These rules may in turn lead to the importation of yet more
  translation units.

  \alinea
  \color{addclr}
  A module implementation unit shall not be exported.
  \begin{example}
  \begin{Program}
// Translation unit \#1
module M:Part;

// Translation unit \#2
export module M;
export import :Part;    // error: exported partition \tcode{:Part} is an implementation unit
  \end{Program}
  \end{example}

% FIXME
%  \alinea
%  \begin{after}\color{addclr}
%  Importing a translation unit $M$
%  \end{after}
%  makes every citation and every
%  %\begin{before}\color{addclr}
%  exported declaration
%  %\end{before}
%  %\begin{after}\color{addclr}
%  %exported name
%  %\end{after}
%  from the 
%  abstract semantics graph of $M$ available, as a citation,
%  %makes exported declarations from the interface of the nominated module visible
%  to name lookup in
%  the current translation unit, in the same namespaces and contexts
%  as in $M$.
%  % the nominated module.
%  \begin{after}\color{addclr}
%  If $M$ is part of the same module as the importing translation unit,
%  importing $M$ also makes every name declared in the purview of $M$
%  that does not have internal linkage visible to name lookup
%  in the current translation unit, in the same namespaces and contexts
%  as in $M$.
%  \end{after}
%  \begin{before}\color{addclr}
%  A \term{citation} for a declaration attached to a module $M$ is a pair of
%  $M$ and the corresponding declset from the abstract semantics graph 
%  of $M$. 
%  \end{before}
%  \begin{after}\color{addclr}
%  A \term{citation} for a declaration in a translation unit $M$ is a pair of
%  $M$ and the corresponding declset from the abstract semantics graph 
%  of $M$. 
%  \end{after}
%%  The \grammarterm{attribute-specifier-seq} appartain to the nominated module.
%  \enternote
%  The declarations in the declsets and the entities denoted by the declsets
%  are not redeclared in the translation unit
%  containing the \grammarterm{module-import-declaration}.
%  \exitnote

% FIXME
%  \begin{after}\color{addclr}
%  \alinea
%  \enternote
%  A \grammarterm{module-import-declaration} also makes all
%  declarations in the purview of the module interface units of $M$
%  reachable in the current translation unit, and may make declarations
%  from the preamble of $M$ reachable in the current translation
%  unit, as described in \ref{dcl.module.reach}.
%  \exitnote
%  \end{after}
%  \begin{example}
%  \begin{Program}
%     // Interface unit of M
%     export module M;
%     export namespace N {
%        struct A { };
%     }
%     namespace N {
%        struct B { };
%        export struct C {
%           friend void f(C) { }  // exported, visible only through argument-dependent lookup
%        };
%     }
%
%     // Translation unit 2
%     import M;
%     N::A a { };                // OK.
%     N::B b { };                // error: `B' not found in N.
%     void h(N::C c) {
%        f(c);                   // OK: `N::f' found via argument-dependent lookup
%        N::f(c);                // error: `f' not found via qualified lookup in N.
%     }
%  \end{Program}
%  \end{example}

  \alinea
  A module implementation unit of a module \tcode{M}
  that is not a module partition
  shall not contain a \grammarterm{module-import-declaration}
  nominating \tcode{M}.
  \begin{example}
  \begin{codeblock}
     module M;
     import M;          // error: cannot import M in its own unit
  \end{codeblock} 
  \end{example}

  \alinea
\begin{before}\color{addclr}
  A module \tcode{M1} \term{has an interface dependency} on a module
  \tcode{M2} if the module interface of \tcode{M1} contains a
  \grammarterm{module-import-declaration} nominating \tcode{M2},
  or if there exists a module \tcode{M3} such that \tcode{M1} has an
  interface dependency on \tcode{M3} and \tcode{M3} has an interface dependency
  on \tcode{M2}.  A module
\end{before}
\begin{after}\color{addclr}
  A translation unit \term{has an interface dependency} on a module unit \tcode{U}
  if it contains a \grammarterm{module-declaration} or
  \grammarterm{module-import-declaration} that imports \tcode{U} or if it has
  an interface dependency on a module unit that has an interface dependency on \tcode{U}.
  A translation unit
\end{after}
  shall not have an interface dependency on itself.
  \begin{example}
  \begin{Program}
     // Interface unit of M1
     export module M1;
     import M2;

     // Interface unit of M2
     export module M2;
     import M3;

     // Interface unit of M3
     export module M3;
     import M1;         // error: cyclic interface dependency M3 -> M1 -> M2 -> M3
  \end{Program}
  \end{example}

\begin{before}\color{addclr}
\alinea
  A translation unit has an interface dependency on a module \tcode{M} if it is
  a module implementation unit of \tcode{M}, or if it contains a
  \grammarterm{module-import-declaration} nominating \tcode{M}, or if it has
  an interface dependency on a module that has an interface dependency on \tcode{M}.
\end{before}
\end{std.txt}

%\begin{before}
%\rSec2[dcl.module.proclaim]{Proclaimed ownership declaration}%
%
%\begin{std.txt}\color{addclr}
%  \begin{bnf}\color{addclr}
%    \nonterminal{proclaimed-ownership-declaration}:\br
%      \terminal{extern} \terminal{module} module-name \terminal{:} declaration
% \end{bnf}
%
% \resetalinea[0]
%  \alinea
%  A \grammarterm{proclaimed-ownership-declaration} shall only appear
%  at namespace scope. 
%  It shall not appear directly or indirectly within an unnamed namespace.
%  A \grammarterm{proclaimed-ownership-declaration} has the declarative effects
%  of its \grammarterm{declaration}.
%  The \grammarterm{declaration} shall declare at 
%  least one name, and the \grammarterm{decl-specifier-seq} (if any)
%  of the \grammarterm{declaration} shall not contain \tcode{static}.
%  The \grammarterm{declaration} shall not be a \grammarterm{namespace-definition},
%  an \grammarterm{export-declaration},
%   or a \grammarterm{proclaimed-ownership-declaration}.
%  The \grammarterm{declaration} shall not be a defining declaration
%  (\ref{basic.def}).
%  A \grammarterm{proclaimed-ownership-declaration} nominating a module $M$
%  shall not appear in the purview of $M$.
%
%  \alinea
%  A \grammarterm{proclaimed-ownership-declaration} asserts that the entities
%  introduced by the declaration are exported by the nominated module. 
%  \enternote
%  A \grammarterm{proclaimed-ownership-declaration} may be used to break
%  circular dependencies between two modules (in possibly too finely
%  designed components.)
%  \begin{example}
%    \begin{codeblock}
%    // TU 1
%    export module Ty;
%    extern module Sym: struct Symbol;
%    export struct Type {
%      Symbol* decl;
%      // ...
%    };
%
%    // TU 2
%    export module Sym;
%    extern module Ty: struct Type;
%    export struct Symbol {
%      const char* name;
%      const Type* type;
%      // ...
%    };
%    \end{codeblock}
%  \end{example}
%  \exitnote
%  
%  \alinea 
%  The program is ill-formed, no diagnostic required, if the
%  nominated module in the  
%  \grammarterm{proclaimed-ownership-declaration} does not export the entities
%  introduced by the declaration. 
%\end{std.txt}
%\end{before}

\rSec2[dcl.module.global]{Global module fragment}

\begin{std.txt}\color{addclr}
\begin{bnf}
\nonterminal{global-module-fragment}:\br
    \terminal{module} \terminal{;} top-level-declaration-seq
\end{bnf}

\resetalinea[0]
\alinea
A \grammarterm{global-module-fragment} specifies the contents of the
\term{global module fragment} for a module unit.
The global module fragment can be used to provide declarations
that are attached to the global module and usable within the module unit.
\enternote
Before preprocessing, only preprocessing directives can appear
in the global module fragment (\ref{cpp.glob.frag}).
\exitnote

\alinea
Declarations in the global module fragment are \term{discarded} if they
are not referenced by the module unit.
\begin{note}
A discarded declaration is neither reachable
nor visible to name lookup outside the module unit,
nor in template instantiations whose points of instantiation
(\stdref{temp.point}{12.7.4.1}) are outside the module unit,
even when the instantiation context (\ref{dcl.module.context})
includes the module unit.
\end{note}
\begin{example}
\begin{codeblock}
// header "foo.h"
namespace N {
  struct X {};
  int f(X);
  int g(X);
  int h(X);
}

// module M interface
module;
#include "foo.h"
export module M;
// \tcode{N::f} is reachable via argument-dependent name lookup result
// in context of template definition
template<typename T> int use_f() { N::X x; f(x); }
// \tcode{N::g} is not reachable because \tcode{g} is a dependent name
// in context of template definition
template<typename T> int use_g() { N::X x; g((T(), x)); }
// \tcode{N::h} is reachable because \tcode{use_h<int>} has a point of
// instantiation in the module unit \tcode{M}
template<typename T> int use_h() { N::X x; h((T(), x)); }
int k = use_h<int>();

// module M implementation
module M;
int a = use_f<int>(); // ok
int b = use_g<int>(); // error: no viable function for call to \tcode{g}
int c = use_h<int>(); // ok
\end{codeblock}
\end{example}

%% Changes: entities now include their declaration context in their basis.
%% We need to retain those contexts so we can mangle the entity.

\alinea
The \term{basis} of a declaration $D$ is a set of entites determined as follows:
\begin{itemize}
\item If $D$ declares a \grammarterm{typedef-name}, the basis is the
type-basis of the aliased type.

\item If $D$ declares a variable or function,
the basis is the union of
the type-basis of the type of that variable or function
and the set containing the
innermost enclosing namespace, class, or function.

\item If $D$ defines a class type, the basis is the union of the
type-bases of its direct base classes (if any), and the bases of
its \grammarterm{member-declaration}{s},
and the set containing the
innermost enclosing namespace, class, or function.

\item If $D$ is a \grammarterm{template-declaration},
the basis is the union
of
\begin{itemize}
\item
the basis of its \grammarterm{declaration},
\item
the set of entities (if any) designated by
the default template arguments for
non-type template parameters and template template parameters,
\item
the type-bases of the default type template arguments,
\item
the set containing the
innermost enclosing namespace, class, or function, and
\item
if $D$ declares a partial specialization,
the set containing the primary template.
\end{itemize}

\item If $D$ is an \grammarterm{explicit-instantiation}
or an \grammarterm{explicit-specialization}, the basis includes
the primary template and all the entities in the basis of the
\grammarterm{declaration} of $D$.

\item If $D$ is a \grammarterm{namespace-definition}, the basis comprises
the innermost enclosing namespace, if any.

\item If $D$ is a \grammarterm{namespace-alias-definition}, the basis is the 
singleton consisting of the namespace denoted by the
\grammarterm{qualified-namespace-specifier}.

\item If $D$ is a \grammarterm{using-declaration}, the basis is the union
of the bases of all the declarations introduced by
the \grammarterm{using-declarator}{s}.

\item If $D$ is an \grammarterm{alias-declaration},
the basis is the type-basis of its \grammarterm{defining-type-id}.

\item Otherwise, the basis is empty.
\end{itemize}

The \term{type-basis} of a type $T$ is
\begin{itemize}
\item If $T$ is a cv-qualified type, the type-basis is the type-basis of
the unqualified type.
\item If $T$ is a member of an unknown specialization, the type-basis
is the type-basis of that specialization.
\item If $T$ is a class template specialization, the type-basis
is the set consisting of
\begin{itemize}
\item the primary template, and
\item the entities designated by
non-type template arguments and
template template arguments (if any), and
\item the elements of the type-bases
of the type template arguments (if any).
\end{itemize}
\item If $T$ is a class type or an enumeration type, 
the type-basis is the singleton $\{ T \}$.
\item If $T$ is a reference to $U$, or a pointer to $U$, or an array of $U$, the
type-basis is the type-basis of $U$.
\item If $T$ is a function type, the type-basis is the union of the
type-basis of the return type and the type-bases of the parameter types.
\item If $T$ is a pointer to data member of a class $X$, the type-basis is
the union of the type-basis of $X$ and the type-basis of member type.
\item If $T$ is a pointer to member function type of a class $X$, the
type-basis is the union of the type-basis of $X$ and the type-basis of
the function type.
\item Otherwise, the type-basis is the empty set.
\end{itemize}

A non-type template argument for a template parameter of pointer type 
that is not value-dependent designates the entity (if any) that the
pointer points to.
A non-type template argument for a template parameter of reference type
that is not value-dependent designates the entity that the argument
denotes.
Other non-type template arguments do not designate an entity.

\alinea
\begin{note}
The basis of a declaration
does not include entities used in expressions,
other than those designated by non-type template arguments.
\begin{example}
\begin{codeblock}
const int size = 2;
int ary1[size];                         // \tcode{size} not in \tcode{ary1}'s basis
constexpr int identity(int x) { return x; }
int ary2[identity(2)];                  // \tcode{identity} not in \tcode{ary2}'s basis

template<typename> struct S;
template<typename, int> struct S2;
constexpr int g(int);

template<typename T, int N>
S<S2<T, g(N)>> f();                     // \tcode{f}'s basis: $\{ \mathtt{S}, \mathtt{S2}, \mathtt{::} \}$ 
\end{codeblock}
\end{example}
\end{note}

\alinea
The \term{interface purview} of a module unit
is its purview excluding any \grammarterm{private-module-fragment}.

\alinea
Certain declarations in a global module fragment are \term{referenced}.
Given an
\grammarterm{identifier},
\grammarterm{unqualified-id},
or expression
in an interface purview or
in a template instantiation whose point of instantiation is in that interface purview:
\begin{itemize}
\item
For an \grammarterm{identifier} or \grammarterm{unqualified-id},
if name lookup for it finds a unique result,
the declaration found is referenced.
\item
For an expression,
the declarations of any function named by it are referenced.
\item
For an expression that governs name lookup for a dependent name,
consider an expression synthesized from it
by replacing each type-dependent argument
with a value of a placeholder type
with no associated namespaces or entities.
All declarations found by name lookup
for the corresponding name
in the synthesized expression are referenced.
\end{itemize}
The declarations of entities in the basis of a referenced declaration are referenced, recursively.
\end{std.txt}

\rSec2[dcl.module.context]{Instantiation context}

\begin{std.txt}\color{addclr}
\resetalinea[0]
\alinea
The \term{instantiation context} is a set of locations within the program
that determines which names are visible to argument-dependent name lookup
(\ref{basic.lookup.argdep})
and which declarations are reachable (\ref{dcl.module.reach})
in the context of a particular declaration or template instantiation.
The instantiation context depends on how the declaration was formed,
or where the template instantiation was referenced.

\alinea
During the implicit definition of a defaulted special member function
(\stdref{special}{10.2.3}),
the instantiation context is the union of
the instantiation context from the definition of the class and
the instantiation context of the program construct that
resulted in the implicit definition of the special member function.

\alinea
During the implicit instantiation of a template
whose point of instantiation is specified as
that of an enclosing specialization (\stdref{temp.point}{12.7.4.1}),
the instantiation context is the union of
the instantiation context of the enclosing specialization and,
if the template is defined in a module interface unit of a module $M$
and the point of instantiation is not in a module interface unit of $M$,
the point at the end of the
\grammarterm{top-level-declaration-seq} of the
primary module interface unit of $M$
(prior to the \grammarterm{private-module-fragment},
if one is present).

\alinea
During the implicit instantiation of a template
that is implicitly instantiated because it is referenced
from within the implicit definition of a defaulted special member function,
the instantiation context is the instantiation context of
the defaulted special member function.

\alinea
During the instantiation of any other template specialization,
the instantiation context comprises the point of instantiation
of the template.

\alinea
In any other case, the instantiation context at a program point comprises
that program point.

\alinea
\begin{example}
\begin{codeblock}
// translation unit \#1
export module stuff;
export template<typename T, typename U> void foo(T, U u) { auto v = u; }
export template<typename T, typename U> void bar(T, U u) { auto v = *u; }

// translation unit \#2
export module M1;
import "defn.h";        // provides \tcode{struct X \{\};}
import stuff;
export template<typename T> void f(T t) {
 X x;
 foo(t, x);
}

// translation unit \#3
export module M2;
import "decl.h";        // provides \tcode{struct X;} (not a definition)
import stuff;
export template<typename T> void g(T t) {
 X *x;
 bar(t, x);
}

// translation unit \#4
import M1;
import M2;
void test() {
  // OK: the instantiation context of \tcode{foo<int, X>} comprises
  // the point at the end of translation unit \#1,
  // the point at the end of translation unit \#2, and
  // the point of the call to \tcode{f(0)} below, so
  // the definition of \tcode{X} is reachable (\ref{dcl.module.reach})
  f(0);

  // the instantiation context of \tcode{foo<int, X>} comprises
  // the point at the end of translation unit \#1,
  // the point at the end of translation unit \#3, and
  // the point of the call to \tcode{g(0)} below, so
  // the definition of \tcode{X} is not necessarily reachable
  g(0);
}
\end{codeblock}
\end{example}
\end{std.txt}

\rSec2[dcl.module.reach]{Reachability}

\begin{std.txt}\color{addclr}
\resetalinea[0]
\alinea
A translation unit is \term{reachable} from a program point if
it is a module interface unit on which the translation unit containing the
program point has an interface dependency, or
it is a translation unit that the translation unit containing the
program point imports,
prior to that program point (\ref{dcl.module.import}).
\enternote
While module interface units are reachable even when they are only
transitively imported via a non-exported import declaration,
namespace-scope names from such module interface units are not visible
to name lookup (\ref{basic.scope.namespace}).
\exitnote

\alinea
It is unspecified whether additional translation units on which the
program point has an interface dependency are considered reachable,
and under what circumstances.%
\footnote{Implementations are not required to prevent the semantic effects of
additional translation units involved in the compilation from being
observed.}
Programs intended to be portable should avoid
depending on the reachability of any additional translation units.

\alinea
A declaration is \term{reachable} if, for any program point in the
instantiation context (\ref{dcl.module.context}),
\begin{itemize}
\item it appears prior to that program point in the same translation unit, or
\item it is not discarded (\ref{dcl.module.global}),
appears in a translation unit that is reachable from that program point,
and
either does not appear within a \grammarterm{private-module-fragment}
or appears in a \grammarterm{private-module-fragment}
of the module containing the program point.
\end{itemize}
\enternote
Whether a declaration is exported has no bearing on whether it is reachable.
\exitnote

\alinea
The \term{reachable semantic properties} of an entity within a context
are the accumulated properties of all reachable declarations of
that entity, and determine the behavior of the entity within
that context.
\enternote
These reachable semantic properties include type completeness,
type definitions, initializers,
default arguments of functions or template declarations, attributes,
visibility of class or enumeration member names to ordinary lookup,
etc.
Since default arguments are evaluated in the context of the call expression,
the reachable semantic properties of the corresponding parameter types apply in 
that context.
\begin{example}
\begin{codeblock}
// translation unit \#1
export module M:A;
export struct B;

// translation unit \#2
module M:B;
struct B {
  operator int();
};

// translation unit \#3
module M:C;
import :A;
B b1;                     // error: no reachable definition of \tcode{struct B}

// translation unit \#4
export module M;
export import :A;
import :B;
B b2;

// translation unit \#5
module X;
import M;
B b3;                     // error: no reachable definition of \tcode{struct B}
\end{codeblock}
\end{example}
\exitnote

\alinea
\enternote
The reachable semantic properties for an entity attached to a module $M$
are the same for all contexts outside that module in which the entity
can be referenced, irrespective of whether $M$ is directly or indirectly
imported.
\exitnote

\alinea
\enternote
An entity can have reachable declarations and therefore
reachable semantic properties even if it is not visible
to name lookup.
\exitnote
\begin{example}
\begin{codeblock}
export module A;
struct X {};
export using Y = X;

module B;
import A;
Y y;            // OK, definition of \tcode{X} is reachable
X x;            // ill-formed: \tcode{X} not visible to unqualified lookup
\end{codeblock}
\end{example}

\begin{before}\color{addclr}
  \alinea
  Within a module interface unit, it is necessary to determine that the
  declarations being exported collectively present a coherent view of 
  the semantic properties of the entities they reference.  This determination
  is based on the semantic properties of attendant entities.
  \enternote
  The reachable semantics properties of an entity, the declarations of which
  are made available via a \grammarterm{module-import-declaration}, are
  determined by its owning module and are unaffected by the importing module.
\end{before}\begin{before}\color{addclr}
  \begin{example}
    \begin{codeblock}
      // module interface of M1
      export module M1;
      export struct S { };

      // module interface of M2
      import M1;
      export module M2;
      export S f();       // \#1
      export S* g();      // \#2

      // elsewhere
      import M2;
      auto x = f();       // OK: completeness of S obtained at \#1
      auto y = *g();      // OK: completeness of S obtained at \#2
    \end{codeblock}
  \end{example}
  \exitnote
\end{before}\begin{before}\color{addclr}
  For each declaration $D$ exported from the module interface unit of a module $M$,
   there is a set of zero or more
  \term{attendant entities} defined as follows:
  \begin{itemize}
    \item If $D$ is a type alias declaration, then the attendant entities
    of $D$ are those determined by the aliased type at the point of the 
    declaration $D$.

    \item If $D$ is a \grammarterm{using-declaration}, the set of attendant entities
    is the union of the sets of attendant entities of the declarations introduced by
    $D$ at the point of the declaration.

    \item If $D$ is a template declaration, the set of attendant entities is 
    the union of the set of attendant entities 
    of the declaration being parameterized, the set of attendant entities
    determined by the default type template arguments (if any), 
    and the set consisting of 
    the entities (if any) designated by the default template template argument,
    the default non-type template arguments (if any).

    \item if $D$ has a type $T$, the set of attendant entities is the set of 
    attendant entities determined by $T$ at the point of declaration.

    \item Otherwise, the set of attendant entities is empty.
  \end{itemize}
\end{before}\begin{before}\color{addclr}
  The \term{set of attendant entities determined by} a type $T$ is defined as follows
  (exactly one of these cases matches):
  \begin{itemize}
    \item\color{addclr} If $T$ is a fundamental type, then
    the set of attendant entities is empty.

  %  \item\color{addclr} If $T$ is a dependent type denoted by a \grammarterm{typename-specifier}
  %  where the \grammarterm{nested-name-specifier} itself denotes a dependent type,
  %  then the set of attendant entities is the set of attendant entities determined by
  %  that type.
    \item\color{addclr} If $T$ is a member of an unknown specialization, the set of
    attendant entities is the set of attendant entities determined by that
    unknown specialization.

    \item\color{addclr} If $T$ is a class type owned by $M$, the set of attendant entities includes
    $T$ itself, the union of the sets of the attendant entities determined
    by its direct base classes owned by $M$, the sets of the
    attendant entities of its data members, static data member templates,
    member functions, member function templates, 
    the function parameters of its constructors and constructor templates.  
    Furthermore, if $T$ is a 
    class template specialization, the set of attendant entities also 
    includes: the class template if it is owned by $M$,
    the union of the sets of attendant entities determined by the type
    template-arguments, the sets of the attendant entities of the templates
    used as template template-arguments, the sets of the attendant entities
    determined by the types of the non-type template-arguments.

    \item\color{addclr} If $T$ is an enumeration type owned by $M$, 
    the set of attendant entities is the singleton $\{T\}$.

    \item\color{addclr} If $T$ is a reference to $U$, or a pointer to $U$, or an array of $U$, 
    the set of attendant entities is the set of attendant entities determined by $U$.

    \item\color{addclr} If $T$ is a function type, the set of attendant entities is the
    union of the set of attendant entities determined by the function
    parameter types and the return type.

    \item\color{addclr} if $T$ is a pointer to data member of class $X$, the set of attendant
    entities is the union of the set of attendant entities of the member type
    and the set of attendant entities determined by $X$.
    
    \item\color{addclr} If $T$ is a pointer to member function type of a class $X$, the
    set of attendant entities is the union of the set of attendant entities
     determined by $X$ and the set of attendant entities determined by
    the function type.
    
    \item\color{addclr} Otherwise, the set of attendant entities is empty.
  \end{itemize}
\end{before}\begin{before}\color{addclr}
  If a class template $X$ is an attendant entity, then its reachable semantic
  properties include all the declarations of the primary class template,
  its partial specializations, and its explicit specializations in the
  containing module interface unit.
  If a complete class type $X$ is an attendant entity, then its reachable
  semantic properties include the declarations of its nested types but
  not the definitions of the types denoted by those members
   unless those definitions are exported.
  Furthermore, if $X$ is an attendant entity of an 
  exported declaration $D$, then its reachable semantic properties are 
  restricted to those defined by the exported declarations of $X$ 
  (if $X$ is introduced by an exported declaration), or by 
  the semantic properties of $X$ available at the point of the declaration $D$.
  \enternote
  If $X$ is a complete class type that is an attendant entity, its nested types
  (including nested enumerations and associated enumerators) 
  and member class templates
  are not considered attendant entities unless they are determined attendant
  entities by one of the rules above.  Attendant entities allow type checking 
  of direct member selection of an object even if that object's type isn't exported.
  Declarations, such as \grammarterm{asm-declaration} or
  \grammarterm{alias-declaration} or 
  \grammarterm{static\_assert-declaration},
   that do not declare entities do not contribute to the set of attendant entities.
  \exitnote
  \begin{example}
    \begin{codeblock}
      export module M;
      export struct Foo;          // Foo exported as incomplete type
      struct Foo { };
      export using ::Foo;         // OK: exports complete type Foo

      struct C { };
      struct S {
        struct B { };
        using C = ::C;
        int i : 8;
        double d { };
      };

      export S f();       // S attendant entity of f().

      // translation unit 2
      import M;
      int main() {
        int x = sizeof(decltype(f())::B);   // error: incomplete B
        int y = sizeof(decltype(f())::C);   // error: incomplete C
        decltype(f()) s { };
        s.d = 3.14;                         // OK
        return &s.i != nullptr;             // error: cannot take address of bitfield
      }
    \end{codeblock}
  \end{example}
\end{before}\begin{before}\color{addclr}
  \alinea
  If $X$ is an attendant entity of two exported declarations
  designating two distinct entities,
  %\begin{after}\color{addclr}
  and $X$ is declared in the purview of the global module,
  %\end{after}
  its reachable semantic properties shall
  be the same at the points where the declarations occur.
  %\begin{before}\color{addclr}
  \begin{example}
    \begin{codeblock}
      export module M;
      struct S;
      export S f();     // \#1
      struct S { };
      export S g();     // error: class type S has different properties from \#1
    \end{codeblock}
  \end{example}
  %\end{before}
  
%  \begin{after}\color{addclr}
%  \begin{example}
%    \begin{codeblock}
%      module;
%      struct S;
%      export module M;
%      export S f();     // \#1
%      extern "C++" struct S { };
%      export S g();     // error: class type S has different properties from \#1
%    \end{codeblock}
%  \end{example}
%  \end{after}
\end{before}
\end{std.txt}
