%!TEX root = std.tex
\setcounter{chapter}{8}
\rSec0[dcl.dcl]{Declarations}%
%\indextext{declaration|(}

%gram: \rSec1[gram.dcl]{Declarations}
%gram:

\noindent
Add new alternatives to \term{declaration} in paragraph 9/1 as follows
\begin{std.txt}
  \begin{bnf}
    \nonterminal{declaration}:\br
      block-declaration\br
      nodeclspec-function-declaration\br
      function-definition\br
      template-declaration\br
      explicit-instantiation\br
      explicit-specialization\br
      linkage-specification\br
      namespace-definition\br
      empty-declaration\br
      attribute-declaration\br
      \added{export-declaration}\br
  \end{bnf}
  \end{std.txt}


\setcounter{section}{0}
\rSec1[dcl.spec]{Specifiers}%

\setcounter{subsection}{5}
\rSec2[dcl.inline]{The \tcode{inline} specifier}%

\noindent
Modify paragraph 9.1.6/6 as follows
\begin{std.txt}
  \resetalinea[5]
  \alinea
  \removed{An}
  \added{If an}
  inline function or variable
  \added{is odr-used in a}
  \removed{shall be defined in every}
  translation unit\added{,
  a definition of it shall be reachable from the end of that translation unit,}
  \removed{in which it is odr-used} and \added{it} shall have exactly 
  the same definition in every \added{such translation unit} \removed{case} (\ref{basic.link}).
  \enternote
  A call to the inline function or a use of 
  the inline variable may be encountered before its definition appears 
  in the translation unit.
  \exitnote
  % 
  If \removed{the} \added{a} definition of a function or variable
  \removed{appears in a translation unit before}
  \added{is reachable at the point of}
  its first declaration as inline,
  the program is ill-formed. If a 
  function or variable with external \added{or module} linkage is 
  declared inline in one translation 
  unit,
  \added{there} \removed{it} shall be
  \added{a reachable} \removed{declared} inline
  \added{declaration} in all translation units in which it 
  \removed{appears}\added{is declared}; 
  no diagnostic is required. An inline function or variable with 
  external \added{or module} linkage 
  shall have the same address in all translation units.
  \enternote
  A \tcode{static} local variable in an inline function with external 
  \added{or module} linkage always refers to the same object. A type 
  defined within the body 
  of an inline function with external \added{or module} linkage is the 
  same type in every translation unit.
  \exitnote
\end{std.txt}

\noindent
Add a new paragraph 9.1.6/7 as follows:
\begin{std.txt}
  \color{addclr}
  \resetalinea[6]
  \alinea
  \added{An exported inline function or variable
  shall be defined in the translation unit
  containing its exported declaration,
  outside the \grammarterm{private-module-fragment} (if any).
  \enternote
  There is no restriction on the linkage (or absence thereof)
  of entities that the function body of an exported inline function
  can reference. A constexpr function (9.1.5) is implicitly inline.
  \exitnote}
\end{std.txt}

\setcounter{section}{6}
\rSec1[basic.namespace]{Namespaces}%
%\indextext{namespaces|(}

\noindent
Add a new paragraph after 9.7/1 as follows:
\begin{std.txt}
  \resetalinea[0]
  \alinea
  A namespace is an optionally-named declarative region. The name of a
  namespace can be used to access entities declared in that namespace;
  that is, the members of the namespace. Unlike other declarative
  regions, the definition of a namespace can be split over several
  parts of one or more translation units.

  %\begin{before}
  %\added{A namespace with external linkage is always 
  %  exported regardless of whether any of its \term{namespace-definition}{s} is
  %  introduced by \tcode{export}.
  %  \enternote
  %  There is no way to define a namespace with module linkage.
  %  \exitnote
  %}\color{addclr}
  %\begin{example}
  %\begin{codeblock}
  %  export module M;
  %  namespace N {    // N has external linkage and is exported
  %  }
  %\end{codeblock}
  %\end{example}
  %\end{before}
  \alinea
  \begin{after}
  \added{\enternote A namespace name with external linkage is exported
  if any of its \term{namespace-definition}{s} is
  exported, or if it contains any
  \grammarterm{export-declaration}{s} (\ref{module.interface}).
  A namespace is never attached to a module, and never has module
  linkage even if it is not exported.
  \exitnote}
  \color{addclr}
  \begin{example}
  \begin{codeblock}
    export module M;
    namespace N1 {}                     // \tcode{N1} is not exported
    export namespace N2 {}              // \tcode{N2} is exported
    namespace N3 { export int n; }      // \tcode{N3} is exported
  \end{codeblock}
  \end{example}
  \end{after}
\end{std.txt}
