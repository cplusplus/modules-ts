\setcounter{chapter}{0}
\rSec0[bg]{Background}

\rSec1[bg.intro]{Introduction}

At the Jacksonville 2018 committee meeting,
P0947R0 (``Another Take On Modules'',
hereafter referred to as \term{Atom})
was presented. Two options were polled:

\begin{itemize}
\item merging the Atom proposal with the Modules TS, and
\item progressing the Atom proposal as a separate TS.
\end{itemize}

Both options passed, but the first option had stronger support.
This paper describes our effort in merging the two proposals
and the remaining outstanding questions from the merge,
and provides wording for the resulting merged specification.

\rSec1[bg.conventions]{Stylistic conventions}

The wording section of this document describes a ``diff of a diff.''
The usual convention of using text style for \added{added} and
\removed{removed} text does not work well for such situations.
In its place, we use block-style diffs
showing the text of the Modules TS
before and after this document is applied:

\begin{before}
Here is some text from the \Cpp standard
\added{with some additions from the Modules TS}.
\end{before}

\begin{after}
Here is some text from the \Cpp standard
\added{with some additions from the Modules TS}
\added{and some more from the Atom proposal}.
\end{after}

Unchanged text from the Modules TS is retained in this document so that a
complete picture of the ``after'' wording may be obtained by simply ignoring
the ``before'' regions.

\rSec0[merged]{Summary of merged proposal}

\rSec1[merged.basic]{Basics}

\pnum
A \term{module unit} begins with a preamble,
comprising a module declaration
and a sequence of imports:

\begin{codeblock}
export@\opt@ module foo;
import a;
export import b;
// ... more imports ...
\end{codeblock}

Within a module unit, imports may only appear within the preamble.
The \tcode{export} keyword indicates that a module unit is a
\term{module interface unit}, which defines the interface for the module.
For a module \tcode{foo}, there must be exactly one
translation unit whose preamble contains \tcode{export module foo;}.
This is the \term{primary module interface unit}
for \tcode{foo}~(\ref{merged.part}).

\pnum
A declaration can be exported by use of the \tcode{export} keyword:
\begin{codeblock}
export int a;
export {
void f();
}
\end{codeblock}
Imports control which namespace-scope names are visible to name lookup.
Names introduced by exported declarations
are visible to name lookup outside the module,
in contexts that import that module.
Names introduced by non-exported declarations are not.

\pnum
The behavior of an entity is determined by
the set of reachable declarations of that entity.
Entities introduced after the preamble in a module unit
are owned by that module;
when such an entity is used outside that module,
its reachable declarations are those
that are part of the interface of the module.
In particular, a class, function, template, etc.
that is owned by a module
always has the same semantics
when viewed from outside the module.
Within a module unit of the owning module,
the semantic properties accumulate throughout the file.
Class members and enumeration members are visible to name lookup
if there is a reachable definition of the class or enumeration.

\pnum
Exported declarations are reachable outside the module.
When an entity is exported,
it must be exported on its first declaration,
and all exported declarations of that entity
are required to precede any non-exported declaration.
If an entity has no exported declarations
all declarations of that entity
within the interface of the module
are considered reachable.
 
\pnum
Declarations in the module interface (excluding those with internal linkage)
are visible and reachable in implementation units of the same module,
regardless of whether they are exported.

\rSec1[merged.part]{Module partitions}

\pnum
A complete module can be defined in a single source file.
However, the design, nature, and size of a module may warrant
dividing both the implementation and the interface
into multiple files.
Module partitions provide facilities to support this.

\pnum
The module interface may be split across multiple files,
if desired.
Such files are called \term{module interface partition}{s}, and are
introduced by a module declaration containing a colon:

\begin{codeblock}
export module foo:part;
\end{codeblock}

\pnum
Module partitions behave logically like distinct modules,
except that they share ownership of contained entities
with the module that they form part of.
This allows an entity to be declared in one partition
and defined in another,
which may be necessary to resolve
dependency cycles.
It also permits code to be moved between partitions of a module
with no impact on ABI.

\pnum
The primary module interface unit for a module is required
to transitively import and re-export all of the interface
partitions of the module.

\pnum
When the implementation of a module is split across multiple files,
it may be desirable to share declarations between the implementation units
without including them in the module interface unit,
in order to avoid all consumers of the module
having a physical dependency on the implementation details.
(Specifically, if the implementation details change,
the module interface and its dependencies should not need to be rebuilt.)
This is made possible by \term{module implementation partition}{s},
which are module partitions that do not form part of the module interface:

\begin{codeblock}
module foo:part;
\end{codeblock}

\pnum
Module implementation partitions cannot contain exported declarations;
instead, all declarations within them are visible to other translation
units in the same module that import the partition.
\begin{note}
Exportation only affects which names and declarations are visible outside
the module.
\end{note}

\pnum
Module implementation partitions can be imported
into the interface of a module,
but cannot be exported.

\pnum
Module interface partitions and module implementation partitions
are collectively known as \term{module partition}{s}.
Module partitions are an implementation detail of the module,
and cannot be named outside the module.
To emphasize this, an import declaration naming a module partition
cannot be given a module name, only a partition name:

\begin{codeblock}
module foo;
import :part;           // imports foo:part
import bar:part;        // syntax error
import foo:part;        // syntax error
\end{codeblock}

\rSec1[merged.nonmodular]{Support for non-modular code}

\pnum
This proposal provides several features to support
interoperation between modular code
and traditional non-modular code.

\rSec2[merged.legacy.frag]{Global module fragment}

\pnum
The merged proposal permits Modules TS-style global module fragments,
with the \tcode{module;} introducer proposed in P0713R1
and approved by EWG:

\begin{codeblock}
module;
#include "some-header.h"
export module foo;
// ... use declarations and macros from some-header.h ...
\end{codeblock}

\pnum
Only \tcode{\#include}{s} are permitted to appear
in the global module fragment,
but there are no special restrictions
on the contents of the \tcode{\#include}{d} file.

\pnum
Declarations from code in the global module fragment
are not owned by the module,
and are not reachable from outside the module by default.
Instead, such declarations become reachable if they are referred to
by an exported declaration
(or transitively if they are referred to by another reachable declaration).
Two important special cases are that an \tcode{export using}
declaration exports both the nominated name and
all reachable declarations of that name,
and an exported function declaration exports
all reachable declarations of its return type:

\begin{codeblock}
module;
#include "some-header.h" // defines class \tcode{X} and \tcode{Y}
export module foo;

export using X = ::X; // export name \tcode{X}; export all declarations
                      // of \tcode{X} from \tcode{"some-header.h"}
export Y f(); // export name \tcode{f}; export all declarations
              // of \tcode{Y} from \tcode{"some-header.h"}
\end{codeblock}

\rSec2[merged.legacy.import]{Legacy header units}

\pnum
The merged proposal also permits Atom-style legacy header units,
which are introduced by a special \tcode{import} syntax
that names a header file instead of a module:

\begin{codeblock}
export module foo;
import "some-header.h";
// ... use declarations and macros from some-header.h ...
\end{codeblock}

\pnum
The named header is processed as if it was a source file,
the interface of the header is extracted and made available for import,
and any macros defined by preprocessing the header are saved
so that they can be made available to importers.

\pnum
Declarations from code in a legacy module header
are not owned by any module.
In particular, the same entities can be redeclared
by another legacy header unit or by non-modular code.
Legacy module headers can be re-exported
using the regular \tcode{export import} syntax:

\begin{codeblock}
export module foo;
export import "some-header.h";
\end{codeblock}

However, when a legacy header unit is re-exported,
macros are not exported.
Only the legacy header import syntax can import macros.

\pnum
Just like declarations within a named module,
declarations within a legacy header unit
are reachable only if the legacy header unit is imported.
(There is no special rule for declarations
that are referred to by an exported declaration.)

\rSec2[merged.nonmodular.use]{Module use from non-modular code}

\pnum
Modules and legacy header units can be imported into non-modular code.
Such imports can appear anywhere, and are not restricted to a preamble.
This permits ``bottom-up'' modularization,
whereby a library switches to providing only a modular interface
and defining its header interface in terms of the modular interface.
Headers imported as legacy header units are treated as non-modular code
in this regard.

\pnum
When a \tcode{\#include} appears within non-modular code,
if the named header file is known to correspond to a legacy header unit,
the implementation treats the \tcode{\#include} as an import
of the corresponding legacy header unit.
The mechanism for discovering this correspondence
is left implementation-defined;
there are multiple viable strategies here
(such as explicitly building legacy header modules and
providing them as input to downstream compilations, or
introducing accompanying files describing the legacy header structure)
and we wish to encourage exploration of this space.
An implementation is also permitted to not provide any mapping mechanism,
and process each legacy header unit independently.

\rSec1[merged.temp]{Templates}

\pnum
Template instantiations are notionally performed in ``instantiation units'',
not within translation units that might contain imports.
We must therefore specify
which names are visible and
which declarations are reachable
in these instantiation units.

\pnum
The rules follow from a simple principle:
when code at some point $X$ triggers a template instantiation,
that instantiation should be able to reach (at least)
the declarations that were reachable at $X$.
Therefore, within a template instantiation,
a declaration is reachable if
it was reachable at one of the points where
an enclosing instantiation was triggered.
If that point is in the translation unit
containing the point of instantiation,
this includes all declarations reachable
at that point;
if the point is in an intervening instantiation
in a module interface,
only declarations that would be reachable
to an importer of that module
or that are visible through an import of that module
are reachable.
\begin{note}
This only matters for entities that are
not owned by a named module:
for entities owned by a named module,
a superset of the above properties
are always reachable outside the owning module.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
export module A;
// instantiation of this template...
export template<typename T> auto f(T t, T t) {
  return t * t;
}
\end{codeblock}

\begin{codeblock}
export module B;
import B;
import "my_complex.h";
// ... finds declarations that are reachable here ...
export template<typename T> auto g(T t) {
  my_complex<T> v(1, t);
  return f(v, v);
}
\end{codeblock}

\begin{codeblock}
module C;
import B;
import "my_rational.h";
// ... and those that are reachable here
void use() {
  g<my_rational>(1);
}
\end{codeblock}

\tcode{my_complex} and \tcode{my_rational} are complete
types within the template instantiation,
even though
\tcode{my_complex} is not a complete type
in either module \tcode{A} or module \tcode{C}.
\end{example}

\pnum
In addition to semantic properties of entities,
we must determine which names are found by
argument-dependent name lookup.
For that purpose,
we follow the Modules TS rule
(subject to ongoing work on P0923)
for associated entities owned by a named module
and make functions visible
if they are declared in that module,
in the same namespace as the associated entity.
For associated entities not owned by a named module,
functions are visible to
argument-dependent name lookup
if they are declared
in the same namespace as the associated entity,
and are visible at a point where
an enclosing instantiation
was triggered.
\begin{example}
In the previous example,
\tcode{operator*} can be found by
argument-dependent name lookup
in the legacy header modules for
\tcode{"my_complex.h"} and
\tcode{"my_rational.h"}.
\end{example}

\rSec0[vs]{Comparison to prior proposals}

\rSec1[vs.ts]{Changes to the Modules TS}

\pnum
This section lists the ways in which valid code under the Modules TS
would become invalid or change meaning in this merged proposal.

\pnum
A \tcode{module;} introducer is required prior to a global module fragment,
as described in P0713R1 and approved by Evolution.

\pnum
When an entity is owned by a module and is never exported,
but is referenced by an exported part of the module interface,
the Modules TS would export the semantic properties
associated with the entity at the point of the export.
If multiple such exports give the entity different semantics,
the program is ill-formed:

\begin{codeblock}
export module M;
struct S;
export S f();  // \tcode{S} incomplete here
struct S {};
export S g();  // \tcode{S} complete here, error
\end{codeblock}

Under the Atom proposal,
the semantics of such entities
are instead determined their the properties
at the end of the module interface unit,
and that is the rule used in this merged proposal.
This is similar to the resolution of P0906R0 issue 1,
as discussed and approved by Evolution,
under which the semantic properties at the last such export are used.
The difference can be observed in a module such as:

\begin{codeblock}
export module M;
struct S;
export S f();
struct S {};
\end{codeblock}

In the P0906R0 approach,
the return type of \tcode{f()} is incomplete
in importers of \tcode{M},
so \tcode{f()} cannot be called.
In this merged proposal,
the return type of \tcode{f()} is complete
because a definition of \tcode{S}
appears within the interface unit.
\begin{note}
The order in which declarations appear within a module interface
has no bearing on which semantic properties are exported
in this merged proposal.
\end{note}

The Modules TS ``attendant entities'' rule is removed,
because there are no longer any cases where it could apply.

\pnum
Entities declared within \tcode{extern "C"} and \tcode{extern "C++"}
within a module are no longer owned by that module.
It is unclear whether this is a change from the intent of
the Modules TS.

\pnum
The global module fragment can only
directly contain \tcode{\#include} directives,
not arbitrary code.

\rSec1[vs.atom]{Changes relative to the Atom proposal}

\pnum
This section lists the ways in which valid code under the Atom proposal
would become invalid or change meaning in this merged proposal.

\pnum
When multiple declarations are provided for an entity,
and only some of them are declared \tcode{export},
only the semantic effects of the exported declarations
are reachable outside the module.
Under the Atom proposal,
\tcode{export} only controls name visibility,
and all semantic effects in the module interface unit
(and in module partitions exported by it)
are exported.
The Atom rule intends to ensure that
reordering declarations cannot affect the exported semantics.
However, applying that change to the Modules TS
would interfere with its goal to always allow modules
to always be defined in a single source file.
The merged rule provides both properties.
The Atom rule is used for entities that are never exported.

\pnum
The merged proposal supports global module fragments,
which interferes with the Atom proposal's goal
of making the preamble easy to identify and process
with non-compiler tools.
However, the benefits of the Atom approach are still available
to those who choose not to put code in the global module fragment.

\pnum
Under the Atom proposal,
we considered restricting the preprocessor constructs that may appear
within the preamble.
In this merged proposal,
the global module fragment is restricted
to only containing \tcode{\#include} directives,
but there are no restrictions on the contents
of the included file
as such restrictions would harm the ability
to put arbitrary code in the global module fragment,
as required by the Modules TS's legacy header support.

\pnum
The identifiers \tcode{export} and \tcode{module} are taken as keywords
by the merged proposal,
rather than making them context-sensitive as proposed by the Atom proposal.
This follows EWG's direction on this question from discussion of P0924R0.

\pnum
The Atom proposal's rule for export of namespace names has not been adopted,
pending further discussion. See \ref{vs.open.namespace}.

\pnum
The Atom rule for declaration reachability
has been relaxed to allow declarations owned by modules
to be considered reachable even if the owning module
is not reachable through a path of imports.

\rSec2[vs.atom.extra]{Atom features not merged}

\pnum
Two features of the Atom proposal were not presented at Jacksonville
due to time constraints.
Because these features have not been discussed in Evolution,
they are not part of the merged wording. They are:

\begin{itemize}
\item
\tcode{public import} declarations.
These declarations provide a mechanism to re-export
the semantic properties of a module
without re-exporting its introduced names.
Such functionality is rendered mostly unnecessary
by the more liberal reachability rule
used for entities owned by modules
in the merged proposal.

\item
\tcode{\#export} directives.
These preprocessor directives provide a mechanism
to export specific macros from named modules.
We anticipate further discussion on this topic
in the context of P0877R0 and P0955R0.
\end{itemize}

\rSec1[vs.open]{Open questions}

\pnum
While performing the merge, we encountered a few issues
for which we did not reach an agreement on the superior answer
and would like to solicit EWG input.

\rSec2[vs.open.namespace]{Namespace export}

\pnum
Under the Modules TS,
all namespaces
(excluding anonymous namespaces and those nested within them)
that are declared in a module interface unit
have external linkage and
are exported.
Under the Atom proposal,
all such namespace names
still have external linkage,
but are only exported if they are either
explicitly exported, or
if any name within them is exported.
\begin{note}
The Atom proposal permits implementation-detail namespace names
to be hidden from the interface of a module
despite being declared in a module interface unit.
\end{note}

\pnum
\begin{example}
\begin{codeblock}
export module M;

export namespace A {} // exported in Atom, TS, and merged proposal
namespace B {         // exported in Atom, TS, and merged proposal
  export int n;
}
namespace C {         // exported in TS and merged proposal, not in Atom
  int n;
}
\end{codeblock}
\end{example}

\rSec2[vs.open.import.lex]{Lexing after \tcode{import}}

\pnum
The Atom proposal introduces a change in the \Cpp{} lexing rules.
After the \tcode{import} token,
the preprocessor attempts to form a \term{header-name}
token where possible.
This permits usage of normal header names:

\begin{codeblock}
import <foo.h>;       // forms \tcode{<foo.h>} header-name token
import "bar\baz.h";   // forms \tcode{"bar\\baz.h"} header-name token
\end{codeblock}

\pnum
It has been suggested that we instead require use of
raw string literals for header names with escape sequences:

\begin{codeblock}
import R<foo.h>;       // forms \tcode{R<foo.h>} token
import R"bar\baz.h";   // forms \tcode{R"bar\\baz.h"} token
\end{codeblock}

This avoids the need for a context-sensitive lexing rule,
but introduces a new form of raw angled string literal,
and has a \term{header-name} syntax distinct from
that used by a \tcode{\#include}.

\rSec2[vs.open.nonexport]{Syntax for non-exported declarations}

\pnum
Following the Modules TS,
the syntax for making a subset
of the semantic properties of an entity reachable
is to omit the \tcode{export} keyword
from some redeclarations:

\begin{codeblock}
export module M;
export struct S;
// ...
struct S { ... };
\end{codeblock}

\pnum
This is not completely satisfying:
\begin{itemize}
\item the simplest syntax is reserved for a case that is
relatively rare in many code bases, and definitions may
fail to be exported by accident
\item the fact that the definition of \tcode{S} is not exported
is an important semantic property of the code,
but the code lacks a way to express that semantic property
\item unlike other specifiers affecting the linkage
of an entity, \tcode{export} is not inherited by redeclarations
\item this behavior does not extend to entities where
no declaration is exported
\end{itemize}

As an alternative, an explicit syntax could be used
to specify that a declaration is excluded from the module interface
despite being in the module interface unit.
As a possible syntax:

\begin{codeblock}
export module M;
export struct S;
export struct T;
// ...
struct S { ... };                    // definition exported
export(false) struct T { ... };      // definition not exported,
                                     // despite \tcode{T} being exported
\end{codeblock}
