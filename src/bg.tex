\setcounter{chapter}{0}
\rSec0[bg]{Background}

\rSec1[bg.intro]{Introduction}

At the Jacksonville 2018 committee meeting,
P0947R0 (``Another Take On Modules'',
hereafter referred to as \term{Atom})
was presented. Two options were polled:

\begin{itemize}
\item merging the Atom proposal with the Modules TS, and
\item progressing the Atom proposal as a separate TS.
\end{itemize}

Both options passed, but the first option had stronger support.

At Rapperswill 2018, we presented P1103R0, representing
our effort in merging the two proposals
and the remaining outstanding questions from the merge.
Many open questions were answered, and we voted to adopt the
merged proposal into the Modules TS, and
scheduled a 2-day ad-hoc meeting to discuss the remaining
open questions.

At the Bellevue 2018 ad-hoc Modules meeting, we answered all
remaining known open design questions. This paper provides a
description for the resulting design, as well as wording
(based on the wording in P1103R0, which in turn is based on
the wording of the Modules TS) to incorporate this design
into the C++20 working draft.

\rSec1[bg.ack]{Acknowledgements}

This paper is based on the work of a great many people.
The author would like to thank them all, and specifically
Gabriel Dos Reis, on whose Modules TS this paper is primarily
based.

%\rSec1[bg.conventions]{Stylistic conventions}
%
%The wording section of this document describes a ``diff of a diff.''
%The usual convention of using text style for \added{added} and
%\removed{removed} text does not work well for such situations.
%In its place, we use block-style diffs
%showing the text of the Modules TS
%before and after this document is applied:
%
%\begin{before}
%Here is some text from the \Cpp standard
%\added{with some additions from the Modules TS}.
%\end{before}
%
%\begin{after}
%Here is some text from the \Cpp standard
%\added{with some additions from the Modules TS}
%\added{and some more from the Atom proposal}.
%\end{after}
%
%Unchanged text from the Modules TS is retained in this document so that a
%complete picture of the ``after'' wording may be obtained by simply ignoring
%the ``before'' regions.

\rSec0[merged]{Summary of merged proposal}

\rSec1[merged.basic]{Basics}

\pnum
A \term{module unit} is a translation unit that forms part of a module.
Such a translation unit begins with%
\footnote{A global module fragment (\ref{merged.global.frag}) may optionally
precede the preamble.}
a preamble,
comprising a module declaration
and a sequence of imports:

\begin{codeblock}
export@\opt@ module foo;
import a;
export import b;
// ... more imports ...
\end{codeblock}

Within a module unit, imports may not appear after the end of the preamble.
The \tcode{export} keyword indicates that a module unit is a
\term{module interface unit}, which defines the interface for the module.
For a module \tcode{foo}, there must be exactly one
translation unit whose preamble contains \tcode{export module foo;}.
This is the \term{primary module interface unit}
for \tcode{foo}~(\ref{merged.part}).
(All other module interface units are module interface partitions;
see \ref{merged.part}.)

\pnum
Two related but distinct notions are key to understanding module semantics:
\begin{itemize}
\item A declaration is \term{visible} in a context if it can be found by a
suitable name lookup.
\item A declaration is \term{reachable} in a context if its semantic effects
are available for use. (For example, a class type is complete in contexts
where a definition of the class is reachable.)
\end{itemize}
A declaration is reachable wherever it is visible, but the converse is not true
in general.
Imports control which namespace-scope names are visible to name lookup,
and which declarations are reachable semantically.
The behavior of an entity is determined by
the set of reachable declarations of that entity.
For example, class members and enumeration members are visible to name lookup
if there is a reachable definition of the class or enumeration.
 
\pnum
A declaration can be exported by use of the \tcode{export} keyword
in a module interface unit:
\begin{codeblock}
export int a;
export {
void f();
}
\end{codeblock}
Exported declarations in a module interface unit
are visible to name lookup
in contexts that import that module interface unit.
Non-exported declarations (excluding those with internal linkage)
in a module unit
are visible to name lookup
in contexts within the same module that import the module unit.
All declarations in transitively-imported module units
are reachable, whether or not they are exported.
\begin{example}
\begin{codeblock}
// a.cpp
export module A; // interface of module \tcode{A}
int foo() { return 1; }
export int bar();
\end{codeblock}

\begin{codeblock}
// a-impl.cpp
module A;        // implementation of module \tcode{A}, implicitly
                 // considered to import the interface of \tcode{A}
// OK; \tcode{foo()} is visible here (in the same module) even though
// it was not exported from \tcode{A}
int bar() { return foo() + 1; }
\end{codeblock}

\begin{codeblock}
// unrelated.cpp
import A;
int main() {
  bar();         // OK, \tcode{bar} was exported by \tcode{A} and is visible here
  foo();         // error: \tcode{foo} is not visible here
}
\end{codeblock}
\end{example}

\pnum
If a declaration within a namespace is exported,
the enclosing namespace is also implicitly exported
(but other declarations in the namespace are not implicitly exported).
If a namespace is explicitly exported,
all declarations within that namespace definition are exported.

\rSec1[merged.part]{Module partitions}

\pnum
A complete module can be defined in a single source file.
However, the design, nature, and size of a module may warrant
dividing both the implementation and the interface
into multiple files.
Module partitions provide facilities to support this.

\pnum
The module interface may be split across multiple files,
if desired.
Such files are called \term{module interface partition}{s}, and are
introduced by a module declaration containing a colon:

\begin{codeblock}
export module foo:part;
\end{codeblock}

\pnum
Module interface partitions behave logically like distinct modules,
except that they share ownership of contained entities
with the module that they form part of.
This allows an entity to be declared in one partition
and defined in another,
which may be necessary to resolve
dependency cycles.
It also permits code to be moved between partitions of a module
with no impact on ABI.

\pnum
The primary module interface unit for a module is required
to transitively import and re-export all of the interface
partitions of the module.

\pnum
When the implementation of a module is split across multiple files,
it may be desirable to share declarations between the implementation units
without including them in the module interface unit,
in order to avoid all consumers of the module
having a physical dependency on the implementation details.
(Specifically, if the implementation details change,
the module interface and its dependencies should not need to be rebuilt.)
This is made possible by \term{module implementation partition}{s},
which are module partitions that do not form part of the module interface:

\begin{codeblock}
module foo:part;
\end{codeblock}

\pnum
Module implementation partitions cannot contain exported declarations;
instead, all declarations within them are visible to other translation
units in the same module that import the partition.
\begin{note}
Exportation only affects which names and declarations are visible outside
the module.
\end{note}

\pnum
Module implementation partitions can be imported
into the interface of a module,
but cannot be exported.

\pnum
Module interface partitions and module implementation partitions
are collectively known as \term{module partition}{s}.
Module partitions are an implementation detail of the module,
and cannot be named outside the module.
To emphasize this, an import declaration naming a module partition
cannot be given a module name, only a partition name:

\begin{codeblock}
module foo;
import :part;           // imports foo:part
import bar:part;        // syntax error
import foo:part;        // syntax error
\end{codeblock}

\rSec1[merged.nonmodular]{Support for non-modular code}

\pnum
This proposal provides several features to support
interoperation between modular code
and traditional non-modular code.

\rSec2[merged.global.frag]{Global module fragment}

\pnum
The merged proposal permits Modules TS-style global module fragments,
with the \tcode{module;} introducer proposed in P0713R1
and approved by EWG:

\begin{codeblock}
module;
#include "some-header.h"
export module foo;
// ... use declarations and macros from some-header.h ...
\end{codeblock}

\pnum
Prior to preprocessing, only preprocessor directives can appear
in the global module fragment, but those directives can include
\tcode{\#include} directives that expand to declarations, as usual.
Declarations in the global module fragment
are not owned by the module.

\pnum
In order to avoid bloating the interface of a module with declarations
included into its global module fragment, declarations in the global
module fragment that are not (transitively) referenced by the module unit are
discarded.
In particular, such declarations are not reachable from other translation
units that import the module unit, and cannot be found by the second phase
of two-phase name lookup for a template instantiation whose point of
instantiation is outside the module unit.
A declaration in a global module fragment is considered to be referenced if it
is named within the module unit (after the preamble), or if it is mentioned
by a referenced declaration.

\pnum
\begin{example}
\begin{codeblock}
module;
#include "some-header.h" // defines classes \tcode{X}, \tcode{Y}, \tcode{Z}
export module foo;

export using X = ::X; // export name \tcode{X}; retain all declarations
                      // of \tcode{X} from \tcode{"some-header.h"}
export Y f(); // export name \tcode{f}; retain all declarations
              // of \tcode{Y} from \tcode{"some-header.h"}
// \tcode{Z} is not mentioned, so is discarded
\end{codeblock}
\end{example}

\rSec2[merged.header.import]{Header units}

\pnum
The merged proposal also permits Atom-style header units,
which are introduced by a special \tcode{import} syntax
that names a header file instead of a module:

\begin{codeblock}
export module foo;
import "some-header.h";
import <version>;
// ... use declarations and macros from some-header.h and <version> ...
\end{codeblock}

\pnum
The named header is processed as if it was a source file,
the interface of the header is extracted and made available for import,
and any macros defined by preprocessing the header are saved
so that they can be made available to importers.

\pnum
Declarations from code in a header unit
are not owned by any module.
In particular, the same entities can be redeclared
by another header unit or by non-modular code.
Header units can be re-exported
using the regular \tcode{export import} syntax:

\begin{codeblock}
export module foo;
export import "some-header.h";
\end{codeblock}

However, when a header unit is re-exported,
macros are not exported.
Only the header import syntax can import macros.

\rSec2[merged.nonmodular.reachability]{Reachability of nonmodular declarations}

\pnum
A declaration in a global module fragment or header unit
is reachable if it is visible.
It is unspecified whether such a declaration is also reachable
in contexts where it is not visible but is transitively
imported.
(Ideally, such a declaration would not be considered reachable
in such contexts. However, in practice, making transitively-imported
declarations unreachable would impose a severe implementation
cost for some implementations, so we leave the extent to which
this rule is enforced up to the implementation.)

\pnum
Discarded declarations (\ref{merged.global.frag}) from the global module
fragment are never visible nor reachable from outside that module unit.

\rSec2[merged.nonmodular.use]{Module use from non-modular code}

\pnum
Modules and header units can be imported into non-modular code.
Such imports can appear anywhere, and are not restricted to a preamble.
This permits ``bottom-up'' modularization,
whereby a library switches to providing only a modular interface
and defining its header interface in terms of the modular interface.
Non-modular code includes translation units other than module units
(including headers imported as header units), and the global module fragment
of a module unit.

\pnum
When a \tcode{\#include} appears within non-modular code,
if the named header file is known to correspond to a header unit,
the implementation treats the \tcode{\#include} as an import
of the corresponding header unit.
The mechanism for discovering this correspondence
is left implementation-defined;
there are multiple viable strategies here
(such as explicitly building header units and
providing them as input to downstream compilations, or
introducing accompanying files describing the header unit structure)
and we wish to encourage exploration of this space.
An implementation is also permitted to not provide any mapping mechanism,
and process each header unit independently.

\rSec0[vs]{Comparison to prior proposals}

\rSec1[vs.r2]{Changes since R2}

\pnum
This section lists changes to the design of the merged modules proposal
since P1103R2.

\begin{itemize}
\item
Addressed wording feedback from CWG and other parties.
\item
Fixed bug where an incidentally-reachable definition could render other
definitions of the same entity ill-formed:
\begin{codeblock}
// a.h
#ifndef A_H
#define A_H
class X {};
#endif

// b.cc
#include "a.h"
export module B;
X x;

// c.cc
export module C;
import B; // not exported

// d.cc
import C;
#include "a.h" // OK even if definition of X is incidentally visible
               // due to semantic boundaries rule
\end{codeblock}
\item
Fixed unintended divergence from Modules TS that permitted module linkage
entities to have definitions in multiple module units
\end{itemize}

\rSec1[vs.r1]{Changes since R1}

\pnum
This section lists changes to the design of the merged modules proposal
since P1103R1.

\rSec2[vs.r1.p1299r2]{P1299R2: Module preamble is unnecessarily fragile}

\pnum
Prior revisions of this proposal prohibited macros imported from header
units from affecting the set of imports of a module. However, the
complexity of the resulting rule -- for both users and implementations
-- was not considered to be justified by the expected benefit for
tools wishing to perform dependency extraction, so this rule has been
removed.

\pnum
In this proposal, macros imported from a header unit become available
immediately after the import as described in \ref{vs.r0.preamble},
but unlike in R0, such macros can be expanded prior to later
imports in the preamble of a module unit.

\rSec2[vs.r1.p1242r1]{P1242R1: Single-file modules}

\pnum
As described in \ref{vs.ts}, this proposal removes the
Modules TS ``attendant entities'' rule.
This left a feature vacuum:
there was no longer a way to define a module entirely in a single file
without module implementation details being available outside the module.

\pnum
In this proposal, a complete module
(with both interface and implementation)
can be defined in a single source file
by separating the interface from the implementation
with a
\begin{codeblock}
module :private;
\end{codeblock}
marker.

\rSec1[vs.r0]{Changes since R0}

\pnum
This section lists changes to the design of the merged modules proposal
since P1103R0.

\rSec2[vs.r0.namespace]{Namespace export}

\pnum
In P1103R0 and in the Modules TS,
all namespaces
(excluding anonymous namespaces and those nested within them)
that are declared in a module interface unit
have external linkage and
are exported.
Following strong EWG direction in Rapperswil,
in this document such namespace names
are only exported if they are either
explicitly exported, or
if any name within them is exported.
\begin{note}
The new approach permits implementation-detail namespace names
to be hidden from the interface of a module
despite being declared in a module interface unit.
\end{note}
\begin{example}
\begin{codeblock}
export module M;

export namespace A {} // exported
namespace B {         // exported
  export int n;
}
namespace C {         // not exported in this proposal, exported in TS / P1103R0
  int n;
}
\end{codeblock}
\end{example}

\rSec2[vs.r0.templates]{Reachability in template instantiations}

\pnum
Following discussion and direction from Bellevue,
we use a path of instantiation rule to guide
visibility and reachability of declarations
within a template instantiation, based on
the relevant rule from the Atom proposal:

\hfill\begin{minipage}{\dimexpr\textwidth-1cm}
Within a template instantiation, the \term{path of instantiation}
is a sequence of locations within the program,
starting from the ultimate point of instantiation,
via each intervening template instantiation,
terminating at the instantiation in question.
Names are visible and semantic properties are available
within template instantiations
if they would be visible or available
at any point along the path of instantiation,
or (for points outside the current translation unit)
would be visible or available
at the end of the translation unit
containing the relevant point of instantiation.
\begin{flushright}
--- P0947R1, 7.1 Templates and two-phase name lookup
\end{flushright}
\end{minipage}

This rule permits a template to make use of all declarations
that were visible or reachable at each point along its path of instantiation,
even if those declarations are not visible or reachable
in the template definition context nor the template instantiation context.

\pnum
\begin{example}
\begin{codeblock}
export module A;
export template<typename T, typename U> void f(T t, U u) {
  t.f();
}
\end{codeblock}

\begin{codeblock}
module;
struct S { void f(); };
export module B;
import A;
export template<typename U> void g(U u) { S s; f(s, u); }
\end{codeblock}

\begin{codeblock}
export module C;
import B;
export template<typename U> void h(const U &u) { g(u); }
\end{codeblock}

\begin{codeblock}
import C;
int main() { h(0); }
\end{codeblock}

The definition of \tcode{struct S} and
the declaration of its member \tcode{f}
are not reachable from the point of instantiation
of \tcode{f<S, int>}, nor from the template definition.
But this code is valid under this proposal, because
\tcode{S} is reachable from module \tcode{B}, which
is on the path of instantiation.
\end{example}

\pnum
As described above (\ref{merged.nonmodular.reachability}),
implementations are permitted to treat additional declarations
as reachable even if they would not be reachable on the
path of instantiation,
if they are transitively imported at the
point of instantiation.
\begin{example}
\begin{codeblock}
module M;
struct S;
import C;
// unspecified whether a definition of \tcode{S} is reachable
// here or in the instantiation of \tcode{h<S>}
void q(const S &s) { h(s); }
\end{codeblock}
\end{example}

\pnum
The same rule applies to the set of names found by ADL:
names visible along the path of instantiation are visible to ADL.
Internal-linkage declarations within the global module are ignored.
In addition, exported declarations in the owning module of
each associated type are visible to ADL.

\rSec2[vs.r0.preamble]{Finding the end of the preamble}

\pnum
In R0 of this proposal, the preprocessor was burdened with finding
the end of the preamble, and making macros from header units
visible at that point.
That was problematic both for implementers (as it is a challenging rule
to implement) and for users (as code would silently do something
different from what was expected, and imports in a preamble would
behave differently from imports in non-modular code).
This proposal uses a simpler rule:
imported macros become visible immediately after the import declaration.

\rSec1[vs.ts]{Changes to the Modules TS}

\pnum
This section lists the ways in which valid code under the Modules TS
would become invalid or change meaning in this merged proposal.

\pnum
A \tcode{module;} introducer is required prior to a global module fragment,
as described in P0713R1 and approved by Evolution.

\pnum
When an entity is owned by a module and is never exported,
but is referenced by an exported part of the module interface,
the Modules TS would export the semantic properties
associated with the entity at the point of the export.
If multiple such exports give the entity different semantics,
the program is ill-formed:

\begin{codeblock}
export module M;
struct S;
export S f();  // \tcode{S} incomplete here
struct S {};
export S g();  // \tcode{S} complete here, error
\end{codeblock}

Under the Atom proposal,
the semantics of such entities
are instead determined their the properties
at the end of the module interface unit.

In this merged proposal,
the semantics of all entities owned by a module
are determined by their properties
at the end of the module interface unit
(regardless of whether they are exported).
\begin{note}
The order in which declarations appear within a module interface
has no bearing on which semantic properties are exported
in this merged proposal.
\end{note}

The Modules TS ``attendant entities'' rule is removed,
because there are no longer any cases where it could apply.

\pnum
Entities declared within \tcode{extern "C"} and \tcode{extern "C++"}
within a module are no longer owned by that module.
It is unclear whether this is a change from the intent of
the Modules TS.

\pnum
Namespace names are exported less often in this proposal, as discussed above.

\rSec1[vs.atom]{Changes relative to the Atom proposal}

\pnum
This section lists the ways in which valid code under the Atom proposal
would become invalid or change meaning in this merged proposal.

\pnum
The merged proposal supports global module fragments,
which interferes with the Atom proposal's goal
of making the preamble easy to identify and process
with non-compiler tools.
However, the benefits of the Atom approach are still available
to those who choose not to put code in the global module fragment.

\pnum
The identifiers \tcode{export} and \tcode{module} are taken as keywords
by the merged proposal,
rather than making them context-sensitive as proposed by the Atom proposal.
This follows EWG's direction on this question from discussion of P0924R0.
