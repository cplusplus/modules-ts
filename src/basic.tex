%!TEX root = std.tex
\setcounter{chapter}{5}
\rSec0[basic]{Basic concepts}

\rSec1[basic.def]{Declarations and definitions}

Modify paragraph 6.1/1 as follows:

\begin{std.txt}
  \resetalinea[0]
  \alinea
  A declaration (Clause \ref{dcl.dcl}) may introduce one or more names into a
  translation unit or redeclare names introduced by previous declarations.
  If so, the declaration specifies the interpretation and
  \removed{attributes}\added{semantic properties} of these names.
  [...]
  \end{std.txt}

\rSec1[basic.def.odr]{One-definition rule}

\textbf{\color{red}FIXME: Incidental reachability (allowed
by the semantic boundaries rule) should not render a program
ill-formed.}

Change paragraph 6.2/1 as follows:
\begin{std.txt}
  \resetalinea[0]
  \alinea
  \removed{No translation unit shall contain more than one definition
  of any}
  \added{A}
  variable, function, class type, enumeration type, or template
  \added{shall not be defined where a prior definition is reachable
  (\ref{dcl.module.reach})}.
\end{std.txt}

\textbf{\color{red}FIXME: Should we allow multiple definitions
of entities with module linkage now that we have module partitions?}

\begin{example}
\begin{codeblock}
// TU 1
module A;
class X {};
void f(X x) { /*...*/ }

// TU 2
module A;
class X {};
void f(X x);
void g() { X x; f(x); }
\end{codeblock}
\end{example}

Modify opening of paragraph 6.2/6 as follows

\begin{std.txt}
  \resetalinea[5]
  \alinea
  There can be more than one definition of a class type (Clause 10), 
  enumeration type (9.6), inline function with external \added{or module} 
  linkage (9.1.6), 
  inline variable with external \added{or module} linkage (9.1.6), 
  class template (Clause 12), 
  non-static function template (12.6.6),
  static data member of a class 
  template (12.6.1.3), member function of a class template (12.6.1.1), or 
  template specialization for which some template parameters are not 
  specified (12.8, 12.6.5) in a program provided that
  \removed{each definition appears 
  in a different translation unit}
  \added{no prior definition is reachable (\ref{dcl.module.reach})
  at the point where a definition appears}, 
  and provided the definitions satisfy the 
  following requirements. 
\begin{before}
  \added{For an entity with an exported declaration, there shall be only one
   definition of that entity; a diagnostic is required only if the abstract 
   semantics graph of the module contains a definition of the entity.}
   \added{\enternote
   If the definition is not in the interface unit, then at most one module unit can
   have and make use of the definition.
   \exitnote}
\end{before}
\begin{after}
  \added{There shall not be more than one definition
  of an entity with external linkage
  that is attached to a named module (\ref{dcl.module.unit});
  no diagnostic is required unless a prior definition
  is reachable at a point where a later definition appears.}
\end{after}
  Given such an entity named \tcode{D} defined in more than one 
  translation unit, then
\end{std.txt}

\rSec1[basic.scope]{Scope}%

\setcounter{subsection}{5}
\rSec2[basic.scope.namespace]{Namespace scope}

\noindent
Modify paragraph 6.3.6/1 as follows:
\begin{std.txt}
  \resetalinea[0]
  \alinea
  The declarative region of a \grammarterm{namespace-definition} is its
  \grammarterm{namespace-body}. 
  Entities declared in a \grammarterm{namespace-body}
  are said to be members of the namespace, and names introduced by
  these declarations 
  into the declarative region of the namespace are said to be
  \term{member names} of the namespace. A namespace member name
  has namespace
  scope. Its potential scope includes its namespace from the name's
  point of declaration (6.3.2) onwards;
   and for each \grammarterm{using-directive}
  (9.7.3) that nominates the member's namespace, the member's
  potential scope includes that portion of the potential scope of the
  \grammarterm{using-directive} that follows the member's point of
  declaration.
\begin{before}
\added{If a name $X$ (not having internal linkage) is declared
    in a namespace $N$ in the purview of the module
    interface unit of a module $M$, the potential scope of $X$ 
    includes the portion of the namespace $N$ in the purview of
     every module implementation unit of $M$
    and, if the name $X$ is exported, in every translation unit that imports $M$
    after a \grammarterm{module-import-declaration} nominating $M$.
    }
\end{before}
\begin{after}
\added{%
If a translation unit $M$ is imported into a translation unit $N$ (\ref{dcl.module.import}),
the potential scope of a name $X$ declared with namespace scope in $M$
is extended to include the portion of the corresponding namespace
scope in $N$ following the first \grammarterm{module-import-declaration}
or \grammarterm{module-declaration}
in $N$ that directly or indirectly imports $M$ if
} \color{addclr}
\begin{itemize}
\item \added{$X$ does not have internal linkage, and}
\item \added{$X$ is declared after the \grammarterm{module-declaration} in $M$ (if any), and}
\item \added{either $X$ is exported or $M$ and $N$ are part of the same module.}
\end{itemize}
\end{after}
  \color{addclr}
%  ; and for each \term{module-import-declaration} that nominates M,
%  the potential scope of X includes the 
%  portion of the potential scope of the \term{using-directive} that
%  follows that \term{module-import-declaration}. 
   \added{\enternote
    A \grammarterm{module-import-declaration} imports both the named
    translation unit(s) and any modules named by exported
    \grammarterm{module-import-declaration}{s} within them,
    recursively.
   \enterexample}
   \begin{codeblock}
    // Translation unit \#1
    export module M;
    export int sq(int i) { return i*i; }

    // Translation unit \#2
    export module N;
    export import M;

    // Translation unit \#3
    import N;
    int main() { return sq(9); }       // OK: \tcode{sq} from module \tcode{M}
    \end{codeblock}
    \added{
    \exitexample
   \exitnote}
\end{std.txt}


\setcounter{section}{3}
\rSec1[basic.lookup]{Name lookup}

Modify paragraph 6.4/1 as follows:
\begin{std.txt}
  \resetalinea[0]
  \alinea
  The name lookup rules apply uniformly to all names
  (including \grammarterm{typedef-name}{s} (9.1.3),
  \grammarterm{namespace-name}{s} (9.7), and 
  \grammarterm{class-name}{s} (10.1))
  wherever the grammar allows such names in the context discussed by a 
  particular rule.
  Name lookup associates the use of a name with a set of declarations (6.1)
  of that name.
  [...] Only after name lookup, function overload resolution (if applicable)
  and access checking have succeeded are the
  \removed{attributes}\added{semantic properties} introduced by
  the name's declaration
  \added{and its reachable (\ref{dcl.module.reach}) redeclarations}
  used further in the expression processing (Clause 7).
\end{std.txt}

% Moved to dcl.module.reach with some changes.
\begin{before}
Add new paragraph 6.4/5 as follows:
\begin{std.txt}\color{addclr}
  \resetalinea[4]
  \alinea
  \added{A declaration is \term{reachable} from a program point if it can be found
  by unqualified name lookup in its scope.}
\end{std.txt}
\end{before}

\setcounter{subsection}{1}
\rSec2[basic.lookup.argdep]{Argument-dependent name lookup}

\noindent
Modify paragraph 6.4.2/2 as follows:
\begin{std.txt}
  \resetalinea[1]
  \alinea
  For each argument type \tcode{T} in the function call, there is a
  set of zero or more \term{associated namespaces} and a set of
  zero or more \term{associated \removed{classes} \added{entities}}
  \added{(other than namespaces)} to be considered.  The sets of
  namespaces and \removed{classes} \added{entities} are determined
  entirely by the types of the function arguments (and the namespace
  of any template template argument).  Typedef names and
  \grammarterm{using-declaration}{s} used to specify the types do not
  contribute to this set.  The sets of namespaces
  and \removed{classes} \added{entities} are determined in the
  following way:
  \begin{itemize}
  \item[---] If \tcode{T} is a fundamental type, its associated sets
  of namespaces and \removed{classes} \added{entities} are both empty.

  \item[---] If \tcode{T} is a class type (including unions), its
  associated \removed{classes} \added{entities} are the class itself;
  the class of which it is a member, if any; and its direct and
  indirect base classes.  Its associated namespaces are the innermost
  enclosing namespaces of its associated \removed{classes} \added{entities}.
  Furthermore, if \tcode{T} is a class template specialization, its
  associated namespaces and \removed{classes} \added{entities} also
  include: the namespace and \removed{classes} \added{entities}
  associated with the types of the template arguments provided for
  template type parameters (excluding template template arguments);
  \added{the templates used as template template arguments;} the
  namespaces of which any template template arguments are members;
  and the classes of which any member template used as template
  template arguments are members. \enternote Non-type template
  arguments do not contribute to the set of associated namespaces. \exitnote

  \item[---] If \tcode{T} is an enumeration type, its associated
  namespace is the innermost enclosing namespace of its
  declaration\added{, and its associated entities are \tcode{T} and,
  if}\removed{. If} it is a class member, \removed{its associated
  class is} the member's class\removed{; else it has no associated class}.

  \item[---] If \tcode{T} is a pointer to \tcode{U} or an array
  of \tcode{U}, its associated namespaces
  and \removed{classes} \added{entities} are those associated
  with \tcode{U}. 

  \item[---] If \tcode{T} is a function type, its associated
  namespaces and \removed{classes} \added{entities} are those
  associated with the function parameter types and those associated
  with the return type.

  \item[---] If \tcode{T} is a pointer to a data member of
  class \tcode{X}, its associated namespaces
  and \removed{classes} \added{entities} are those associated with the
  member type together with those associated with \tcode{X}.
  \end{itemize}

  If an associated namespace is an inline namespace (9.7.1), its
  enclosing namespace is also included in the set.  If an associated
  namespace directly contains inline namespaces, those inline
  namespaces are also included in the set.  In addition, if the
  argument is the name or address of a set of overloaded functions
  and/or function templates, its
  associated \removed{classes} \added{entities} and namespaces are the
  union of those associated with each of the members of the set, i.e.,
  the \removed{classes} \added{entities} and namespaces associated
  with its parameter types and return type.  Additionally, if the
  aforementioned set of overloaded functions is named with
  a \grammarterm{template-id}, its
  associated \removed{classes} \added{entities} and namespaces also
  include those of its type \grammarterm{template-argument}{s} and its
  template \grammarterm{template-argument}{s}.
\end{std.txt}

\noindent
Modify paragraph 6.4.2/4 as follows:
\begin{std.txt}
  \resetalinea[3]
  \alinea
  When considering an associated namespace, the lookup is the same as
  the lookup performed when the associated namespace is used as a
  qualifier (6.4.3.2) except that:
  \begin{itemize}
    \item[---] Any \grammarterm{using-directive}{s} in the associated
  namespace are ignored.

     \item Any namespace-scope friend declaration functions or friend
  function templates (10.7.3) declared in \removed{associated}
  classes \added{in the set of associated entities} are visible within
  their respective namespaces even if they are not visible during an
  ordinary lookup (9.7.1.2).

     \item All names except those of (possibly overloaded) functions
  and function templates are ignored.

     \color{addclr}
     \item[---]
     \added{Any function or function template in the interface of
     a named module \tcode{M} (\ref{dcl.module}) that has
     the same innermost enclosing non-inline namespace as
     some associated entity attached to \tcode{M}
     is visible within its namespace
     to a lookup that does not occur within a module unit of \tcode{M},
     even if it is not visible during an ordinary lookup.}

    \item[---]
    \added{All declarations that are visible at any point in the instantiation
    context (\ref{dcl.module.context}) of the lookup are visible
    even if they are not visible during an ordinary lookup,
    excluding discarded declarations (\ref{dcl.module.global}) and
    internal linkage declarations attached to the global module.}
  \end{itemize}

\textbf{\color{red}FIXME: Add an example.}
\end{std.txt}

\setcounter{section}{4}
\rSec1[basic.link]{Program and linkage}%

\resetalinea[0]

Change the definition of \term{translation-unit} in paragraph 6.5/1
to:

\begin{bnf}
\nonterminal{translation-unit}:\br
    \added{top-level-}declaration-seq\opt\br
    \added{global-module-fragment\opt module-declaration top-level-declaration-seq\opt private-module-fragment\opt}
\end{bnf}

\begin{bnf}
\added{\nonterminal{private-module-fragment}:\br
    \terminal{module} \terminal{:} \terminal{private} \terminal{;} top-level-declaration-seq\opt}
\end{bnf}

\begin{bnf}\color{addclr}
      \added{\nonterminal{top-level-declaration-seq}:\br
          top-level-declaration\br
          top-level-declaration-seq top-level-declaration}
\end{bnf}

\begin{bnf}\color{addclr}
      \added{\nonterminal{top-level-declaration}:\br
         module-import-declaration\br
         declaration}
\end{bnf}

\noindent
Add new paragraphs after the grammar:

\begin{std.txt}
\alinea
\added{A \grammarterm{private-module-fragment} shall appear only
in a primary module interface unit (\ref{dcl.module.unit}).}

\alinea
\added{A token sequence beginning with
\tcode{export}\opt{} \tcode{module} or
\tcode{export}\opt{} \tcode{import}
and not immediately followed by \tcode{::}
is never interpreted as the \grammarterm{declaration}
of a \grammarterm{top-level-declaration}.}
\end{std.txt}

\noindent
Insert a new bullet between first and second bullet of paragraph 6.5/2:

\begin{std.txt}\color{addclr}
  \begin{itemize}
    \item[---] \added{When a name has \term{module linkage}, the entity it denotes
      can be referred to by names
      from other scopes of the same module unit (\ref{dcl.module.unit}) 
      or from scopes of
      other module units of that same module.}
  \end{itemize}
\end{std.txt}

\noindent
Modify bullet (3.2) of paragraph 6.5/3 as follows:
\begin{std.txt}
  \begin{itemize}
    \item[---]
    %a non-inline \added{non-exported} variable of non-volatile const-qualified type 
    %that is neither explicitly declared \tcode{extern} nor
    %previously declared to have external \added{or module} linkage; or
    a \removed{non-inline} variable of non-volatile const-qualified type\added{,
    unless}
    \begin{itemize}
      \color{addclr}
      \item[---] \added{it is explicitly declared \tcode{extern}, or}
      \item[---] \added{it is inline or exported, or}
      \item[---] \added{it was previously declared and the prior declaration did
      not have internal linkage; or}
    \end{itemize}
    \removed{that is neither explicitly declared \tcode{extern} nor
    previously declared to have external linkage; or}
  \end{itemize}
\end{std.txt}

\noindent
Modify paragraph 6.5/4 as follows:
%\begin{std.txt}
%  \resetalinea[3]
%  \alinea
%  An unnamed namespace or a namespace declared directly or 
%  indirectly within an unnamed namespace has internal linkage. All other 
%  namespaces have external linkage. 
%  \added{A name declared at namespace scope in the purview of a named module
%  that does not have internal linkage by the previous rules and that
%  is not exported has module
%  linkage. The name of any class member where the enclosing class has
%  a name with module linkage also has module linkage.}
%  A name having namespace scope that has 
%  not been given internal \added{or module} linkage above has the same linkage as the enclosing 
%  namespace if it is the name of
%\end{std.txt}
%% New wording suggested by Hubert Tong, on December 17, 2017.
\begin{std.txt}
  \resetalinea[3]
  \alinea
  An unnamed namespace or a namespace declared directly or 
  indirectly within an unnamed namespace has internal linkage. All other 
  namespaces have external linkage. 
  A name having namespace scope that has 
  not been given internal linkage above \removed{has the same linkage as the enclosing 
  namespace if it}\added{and that} is the name of
  \begin{itemize}
    \item a variable; or
    \item a function; or
    \item a named class (Clause 10), or an unnamed class defined in a 
    typedef declaration in which the class has the typedef name for 
    linkage purposes (9.1.3); or
    \item a named enumeration (9.6), or an unnamed enumeration defined in
    a typedef declaration in which the enumeration has the typedef name for
    linkage purposes (9.1.3); or
    \item a template\removed{.}
  \end{itemize}
  \begin{before}\color{addclr}
  \added{has the same linkage as the enclosing namespace if}
    \begin{itemize}
      \item \added{said namespace has internal linkage, or}
      \item \added{the name is exported (\ref{dcl.module.interface}), or}
      \added{is declared in a \grammarterm{proclaimed-ownership-declaration},
      or is not being declared in the purview of
      a named module (\ref{dcl.module.unit});}
    \end{itemize}
    \added{otherwise, the name has module linkage.}
  \end{before}
  \begin{after}\color{addclr}
  \added{has its linkage determined as follows:}
    \begin{itemize}\color{addclr}
      \item \added{if the enclosing namespace has internal linkage,
      the name has internal linkage;}
      \item \added{otherwise, if
      the declaration of the name is
      attached to a named module (\ref{dcl.module.unit})
      and is not exported (\ref{dcl.module.interface}),
      %and is not declared in a
      %\grammarterm{proclaimed-ownership-declaration} or a
      %\grammarterm{linkage-specification},
      the name has module linkage;}
      \item \added{otherwise, the name has external linkage}.
    \end{itemize}
  \end{after}
\end{std.txt}


\noindent
Modify 6.5/6 as follows:
\begin{std.txt}
\resetalinea[5]
\alinea
The name of a function declared in block scope and the name of a
variable declared by a block scope extern declaration have linkage.
\added{If such a declaration is attached to a named module,
the program is ill-formed.}
If there is a visible declaration of an entity with linkage having the
same name and type, ignoring entities declared outside the innermost
enclosing namespace scope, the block scope declaration declares that
same entity and receives the linkage of the previous declaration. 
If
there is more than one such matching entity, the program is
ill-formed. Otherwise, if no matching entity is found, the block scope
entity receives external linkage.
\end{std.txt}

\noindent
Modify paragraph 6.5/10 and add /11 as follows:
\begin{std.txt}
  \resetalinea[9]
  \alinea
  \addtocounter{footnote}{1}
  Two
  names that are the same (Clause 6) and that are declared in different scopes
  shall denote the same variable, function, type, template or namespace if
  \begin{itemize}
    \item[---] both names have external \added{or module} linkage
      \added{and are declared in declarations attached to the
      same module,}
      or else both names have internal linkage and are declared in
      the same translation unit; and

      \item both names refer to members of the same namespace or to members,
      not by inheritance, of the same class; and

      \item when both names denote functions, the parameter-type-lists of the
      functions (9.2.3.5) are identical; and

      \item when both names denote function templates, the signatures (12.6.6.1)
      are the same.
  \end{itemize}
  \added{If multiple declarations of the same name with external linkage
  would declare the same entity except that they are attached to different
  modules, the program is ill-formed; no diagnostic is required.
  \enternote
  \grammarterm{using-declaration}{s}, typedef declarations, and 
  \grammarterm{alias-declaration}{s} do not declare entities, but 
  merely introduce synonyms. Similarly, \grammarterm{using-directive}{s}
  do not declare entities.
  \exitnote}

  \alinea
  \added{If a declaration would redeclare a reachable declaration
  attached to a different module, the program is ill-formed.}
  \color{addclr}
  \begin{example}
    \begin{codeblock}
      // \tcode{"decls.h"}
      int f();            // \#1, attached to the global module
      int g();            // \#2, attached to the global module

      // module interface of \tcode{M}
      module;
      #include "decls.h"
      export module M;
      export using ::f;   // OK: does not declare an entity, exports \#1
      int g();            // error: matches \#2, but attached to M
      export int h();     // \#3
      export int k();     // \#4

      // other translation unit
      import M;
      static int h();     // error: matches \#3
      int k();            // error: matches \#4
    \end{codeblock}
  \end{example}
  \added{As a consequence of these rules,
  all declarations of an entity are \term{attached} to the same module;
  the entity is said to be attached to that module.}
\end{std.txt}


\setcounter{section}{7}
\rSec1[basic.exec]{Program execution}

\setcounter{subsection}{2}
\rSec2[basic.start]{Start and termination}

\setcounter{subsubsection}{0}
\rSec3[basic.start.main]{\tcode{main} function}

Modify paragraph 6.8.3.1/1 as follows:
\begin{std.txt}
  \resetalinea[0]
  \alinea
  A program shall contain a global function called \tcode{main}
  \added{attached to the global module}.
\end{std.txt}

Modify paragraph 6.8.3.1/3 as follows:
\begin{std.txt}
  \resetalinea[2]
  \alinea
  ...
  A program that declares a variable \tcode{main} at global scope\added{,
  or that declares a function \tcode{main} at global scope attached to a named module,}
  or that declares the name \tcode{main} with C language linkage (in any namespace)
  is ill-formed.
\end{std.txt}
