%!TEX root = std.tex
\setcounter{chapter}{11}
\rSec0[temp]{Templates}%
%\indextext{template|(}

\noindent
Modify paragraph 12/4 as follows:
\begin{std.txt}
  \pnum[4]
  A \grammarterm{template-declaration} can appear only as a 
  namespace scope or class scope declaration.
  \added{Its \grammarterm{declaration} shall not be an
  \grammarterm{export-declaration}.}
  In a function template declaration, the last component of the 
  \grammarterm{declarator-id} shall not be a \grammarterm{template-id}. 
  [...]
\end{std.txt}


%gram: \rSec1[gram.temp]{Templates}
%gram:

%% \setcounter{section}{5}
%% \rSec1[temp.res]{Name resolution}

%% \setcounter{subsection}{3}
%% \rSec2[temp.dep.res]{Dependent name resolution}

%% \noindent
%% Modify second bullet of paragraph 14.6.4/1
%% \begin{std.txt}
%%   \item Declarations from namespace \added{partitions} associated
%%     with the types of the function arguments both from the
%%     instantiation context (14.6.4.1) and from the definition context. 
%% \end{std.txt}

\setcounter{section}{6}
\rSec1[temp.res]{Name resolution}
\setcounter{subsection}{3}
\rSec2[temp.dep.res]{Dependent name resolution}

Change in 12.7.4/1:

\begin{std.txt}
\pnum[1]
In resolving dependent names, names from the following sources are considered:
\begin{itemize}
\item
Declarations that are visible at the point of definition of the template.
\item
Declarations from namespaces associated with the types of the function
arguments both from the instantiation context
\removed{(12.7.4.1)} \added{(\ref{module.context})}
and from the definition context.
\end{itemize}
\enterexample\color{addclr}
\begin{codeblock}
// header file \tcode{"X.h"}
namespace Q { 
  struct X { };
}

// header file \tcode{"G.h"}
namespace Q {
  void g_impl(X, X);
}

// interface unit of \tcode{M1}
module;
#include "X.h"
#include "G.h"
export module M1;
export template<typename T>
void g(T t) {
  g_impl(t, Q::X{ });   // ADL in definition context finds \tcode{Q::g_impl}, \tcode{g_impl} not discarded
}

// interface unit of \tcode{M2}
module;
#include "X.h"
export module M2;
import M1;
void h(Q::X x) {
   g(x);                // OK
}
\end{codeblock}
\exitexample
\end{std.txt}

\noindent
Add new paragraphs to 12.7.4:
\begin{std.txt}
\color{addclr}
\pnum
\enterexample
\begin{codeblock}
// interface unit of \tcode{Std}
export module Std;
export template<typename Iter>
void indirect_swap(Iter lhs, Iter rhs)
{
  swap(*lhs, *rhs);     // swap can be found only via ADL
}

// interface unit of \tcode{M}
module;
import Std;
export module M;

struct S { /* ...*/ };
void swap(S&, S&);      // \#1;

void f(S* p, S* q)
{
  indirect_swap(p, q);  // finds \#1 via ADL in instantiation context
}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// header file \tcode{"X.h"}
struct X { /* ... */ };
X operator+(X, X);

// module interface unit of \tcode{F}
export module F;
export template<typename T>
void f(T t) {
  t + t;
}

// module interface unit of \tcode{M}
module;
#include "X.h"
import F;
export module M;
void g(X x) {
  f(x);             // OK: instantiates \tcode{f} from \tcode{F},
                    // \tcode{operator+} is visible in instantiation context
}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// module interface unit of \tcode{A}
export module A;
export template<typename T>
void f(T t) {
  t + t;           // \#1
}

// module interface unit of \tcode{B}
export module B;
import A;
export template<typename T, typename U>
void g(T t, U u) {
  f(t);
}

// module interface unit of \tcode{C1}
module;
#include <string>   // \tcode{operator+} not referenced, discarded
export module C1;
import B;
export template<typename T>
void h(T t) {
  g(std::string{ }, t);
}

// translation unit
import C1;
void i() {
   h(0);        // ill-formed: '+' not found at \#1
}

// module interface unit of \tcode{C2}
export module C2;
import B;
import <string>;
export template<typename T>
void j(T t) {
  g(std::string{ }, t);
}

// translation unit
import C2;
void k() {
   j(0);        // OK, '+' found in instantiation context:
                // visible at end of module interface unit of \tcode{C2}
}
\end{codeblock}
\exitexample
\end{std.txt}

\rSec3[temp.point]{Point of instantiation}

\noindent
Delete paragraph 12.7.4.1/7:
\begin{std.txt}
\pnum[7]
\removed{The instantiation context of an expression that depends on
the template arguments is the set of declarations with external
linkage declared prior to the point of instantiation of the
template specialization in the same translation unit.}
\end{std.txt}

\noindent
Change in paragraph \ref{temp.point}/8:
\begin{std.txt}
\pnum[8]
in addition to the points of instantiation described above, for any such
specialization that has a point of instantiation within the
\added{\grammarterm{top-level-declaration-seq} of the}
translation unit,
\added{prior to the \grammarterm{private-module-fragment} (if any),
the point after the \grammarterm{top-level-declaration-seq}
of the \grammarterm{translation-unit}
is also considered a point of instantiation,
and for any such specialization that has a point of instantiation
within the \grammarterm{private-module-fragment},}
the end of the translation unit is also
considered a point of instantiation.
\end{std.txt}

\rSec3[temp.dep.candidate]{Candidate functions}

\noindent
Modify paragraph 12.7.4.2/1 as follows
\begin{std.txt}
\pnum[1]
\ldots
If the call would be ill-formed or would find a better match had the 
lookup within the associated namespaces considered all the function 
declarations with external   \added{or module}
linkage introduced in those namespaces in all
translation units, not just considering those declarations found in the 
template definition and template instantiation contexts, then the program 
has undefined behavior.
\end{std.txt}



