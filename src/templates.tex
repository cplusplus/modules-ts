%!TEX root = std.tex
\setcounter{chapter}{11}
\rSec0[temp]{Templates}%
%\indextext{template|(}

\noindent
Modify paragraph 12/4 as follows:
\begin{std.txt}
  \pnum[4]
  A \grammarterm{template-declaration} can appear only as a 
  namespace scope or class scope declaration.
  \added{Its \grammarterm{declaration} shall not be an
  \grammarterm{export-declaration}.}
  In a function template declaration, the last component of the 
  \grammarterm{declarator-id} shall not be a \grammarterm{template-id}. 
  [...]
\end{std.txt}


%gram: \rSec1[gram.temp]{Templates}
%gram:

%% \setcounter{section}{5}
%% \rSec1[temp.res]{Name resolution}

%% \setcounter{subsection}{3}
%% \rSec2[temp.dep.res]{Dependent name resolution}

%% \noindent
%% Modify second bullet of paragraph 14.6.4/1
%% \begin{std.txt}
%%   \item Declarations from namespace \added{partitions} associated
%%     with the types of the function arguments both from the
%%     instantiation context (14.6.4.1) and from the definition context. 
%% \end{std.txt}

\setcounter{section}{6}
\rSec1[temp.res]{Name resolution}
\setcounter{subsection}{3}
\rSec2[temp.dep.res]{Dependent name resolution}
\rSec3[temp.point]{Point of instantiation}

\noindent
Delete paragraph 12.7.4.1/7:
\begin{std.txt}
\pnum[7]
\removed{The instantiation context of an expression that depends on
the template arguments is the set of declarations with external
linkage declared prior to the point of instantiation of the
template specialization in the same translation unit.}
\end{std.txt}

\noindent
Change in paragraph \ref{temp.point}/8:
\begin{std.txt}
\pnum[8]
in addition to the points of instantiation described above,
\begin{itemize}
\item
for any such
specialization that has a point of instantiation within the
\added{\grammarterm{top-level-declaration-seq} of the}
translation unit,
\added{prior to the \grammarterm{private-module-fragment} (if any),
the point after the \grammarterm{top-level-declaration-seq}
of the \grammarterm{translation-unit}
is also considered a point of instantiation,
and}
\item
\added{for any such specialization that has a point of instantiation
within the \grammarterm{private-module-fragment},}
the end of the translation unit is also
considered a point of instantiation.
\end{itemize}
\end{std.txt}

\rSec3[temp.dep.candidate]{Candidate functions}

\noindent
Modify paragraph 12.7.4.2/1 as follows
\begin{std.txt}
\pnum[1]
For a function call where the \grammarterm{postfix-expression} is a
dependent name,
the candidate functions are found using the usual lookup
rules \added{from the template definition context}~(\stdref{basic.lookup.unqual}{6.4.1}, \ref{basic.lookup.argdep})\added{.}
\removed{except that:}
\added{\enternote}
\begin{itemize}
\item
\removed{For the part of the lookup using unqualified name lookup (\stdref{basic.lookup.unqual}{6.4.1}),
only function declarations
from the template definition context are found.}
\item
For the part of the lookup using associated namespaces (\ref{basic.lookup.argdep}),
\removed{only} function declarations found in \removed{either the template
definition context or} the template instantiation context are found
\added{by this lookup, as described in \ref{basic.lookup.argdep}}.
\end{itemize}
\added{\exitnote}
If the call would be ill-formed or would find a better match had the 
lookup within the associated namespaces considered all the function 
declarations with external
linkage introduced in those namespaces in all
translation units, not just considering those declarations found in the 
template definition and template instantiation contexts, then the program 
has undefined behavior.
\end{std.txt}

Append new paragraphs as follows:

\begin{std.txt}\color{addclr}
\pnum[2]
\enterexample
\begin{codeblock}
// header file \tcode{"X.h"}
namespace Q { 
  struct X { };
}

// header file \tcode{"G.h"}
namespace Q {
  void g_impl(X, X);
}

// interface unit of \tcode{M1}
module;
#include "X.h"
#include "G.h"
export module M1;
export template<typename T>
void g(T t) {
  g_impl(t, Q::X{ });   // ADL in definition context finds \tcode{Q::g_impl}, \tcode{g_impl} not discarded
}

// interface unit of \tcode{M2}
module;
#include "X.h"
export module M2;
import M1;
void h(Q::X x) {
   g(x);                // OK
}
\end{codeblock}
\exitexample

\color{addclr}
\pnum
\enterexample
\begin{codeblock}
// interface unit of \tcode{Std}
export module Std;
export template<typename Iter>
void indirect_swap(Iter lhs, Iter rhs)
{
  swap(*lhs, *rhs);     // \tcode{swap} not found by unqualified lookup, can be found only via ADL
}

// interface unit of \tcode{M}
export module M;
import Std;

struct S { /* ...*/ };
void swap(S&, S&);      // \#1

void f(S* p, S* q)
{
  indirect_swap(p, q);  // finds \#1 via ADL in instantiation context
}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// header file \tcode{"X.h"}
struct X { /* ... */ };
X operator+(X, X);

// module interface unit of \tcode{F}
export module F;
export template<typename T>
void f(T t) {
  t + t;
}

// module interface unit of \tcode{M}
module;
#include "X.h"
export module M;
import F;
void g(X x) {
  f(x);             // OK: instantiates \tcode{f} from \tcode{F},
                    // \tcode{operator+} is visible in instantiation context
}
\end{codeblock}
\exitexample

\pnum
\enterexample
\begin{codeblock}
// module interface unit of \tcode{A}
export module A;
export template<typename T>
void f(T t) {
  cat(t, t);         // \#1
  dog(t, t);         // \#2
}

// module interface unit of \tcode{B}
export module B;
import A;
export template<typename T, typename U>
void g(T t, U u) {
  f(t);
}

// \tcode{"foo.h"}, not an importable header
struct foo {
  friend int cat(foo, foo);
};
int dog(foo, foo);

// module interface unit of \tcode{C1}
module;
#include "foo.h" // \tcode{dog} not referenced, discarded
export module C1;
import B;
export template<typename T>
void h(T t) {
  g(foo{ }, t);
}

// translation unit
import C1;
void i() {
   h(0);        // error: \tcode{dog} not found at \#2
}

// \tcode{"bar.h"}, an importable header
struct bar {
  friend int cat(bar, bar);
};
int dog(bar, bar);

// module interface unit of \tcode{C2}
module;
#include "bar.h" // imports header unit \tcode{"bar.h"}
export module C2;
import B;
export template<typename T>
void j(T t) {
  g(bar{ }, t);
}

// translation unit
import C2;
void k() {
   j(0);        // OK, \tcode{dog} found in instantiation context:
                // visible at end of module interface unit of \tcode{C2}
}
\end{codeblock}
\exitexample
\end{std.txt}
